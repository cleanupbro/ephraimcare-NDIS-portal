---
phase: 05-worker-mobile-app
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/worker-mobile/stores/shiftStore.ts
  - apps/worker-mobile/stores/syncStore.ts
  - apps/worker-mobile/hooks/useShifts.ts
  - apps/worker-mobile/lib/proximity.ts
autonomous: true

must_haves:
  truths:
    - "useShifts hook fetches today's shifts for the logged-in worker ordered by start time"
    - "shiftStore tracks active shift ID and check-in timestamp for timer"
    - "syncStore queues offline check-in/out actions with FIFO ordering"
    - "proximity.ts calculates haversine distance and returns within/distance result"
  artifacts:
    - path: "apps/worker-mobile/hooks/useShifts.ts"
      provides: "TanStack Query hooks for fetching worker shifts (today, week)"
      exports: ["useTodayShifts", "useWeekShifts", "useShiftDetail"]
    - path: "apps/worker-mobile/stores/shiftStore.ts"
      provides: "Zustand store for active shift state (ID, start time)"
      exports: ["useShiftStore"]
    - path: "apps/worker-mobile/stores/syncStore.ts"
      provides: "Zustand persist store for offline action queue"
      exports: ["useSyncStore"]
    - path: "apps/worker-mobile/lib/proximity.ts"
      provides: "Haversine distance calculation and radius check"
      exports: ["getDistanceMeters", "isWithinRadius"]
  key_links:
    - from: "apps/worker-mobile/hooks/useShifts.ts"
      to: "apps/worker-mobile/lib/supabase.ts"
      via: "supabase.from('shifts').select()"
      pattern: "supabase.*from.*shifts"
    - from: "apps/worker-mobile/stores/syncStore.ts"
      to: "@react-native-async-storage/async-storage"
      via: "zustand persist storage adapter"
      pattern: "createJSONStorage.*AsyncStorage"
---

<objective>
Core data hooks, stores, and utilities for the worker mobile app.

Purpose: All screens depend on shift data fetching (useShifts), active shift tracking (shiftStore), offline action queuing (syncStore), and GPS proximity checking (proximity.ts). These are the shared building blocks that home, detail, schedule, and check-in/out screens all consume.

Output: TanStack Query hooks for shifts, zustand stores for active shift + sync queue, haversine proximity utility.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-worker-mobile-app/05-RESEARCH.md
@apps/worker-mobile/lib/supabase.ts
@apps/worker-mobile/constants/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shift data hooks with TanStack Query</name>
  <files>apps/worker-mobile/hooks/useShifts.ts</files>
  <action>
Create TanStack Query hooks for fetching worker shifts from Supabase:

```typescript
// hooks/useShifts.ts
import { useQuery } from '@tanstack/react-query'
import { supabase } from '../lib/supabase'
import { startOfDay, endOfDay, startOfWeek, endOfWeek } from 'date-fns'

// Types for shift data
export interface ShiftWithParticipant {
  id: string
  participant_id: string
  worker_id: string
  scheduled_date: string
  scheduled_start: string
  scheduled_end: string
  support_type: string
  status: string
  notes: string | null
  participant: {
    id: string
    first_name: string
    last_name: string
    address: string | null
    latitude: number | null
    longitude: number | null
    medical_alerts: string | null
    special_instructions: string | null
  }
  shift_check_ins: {
    id: string
    check_in_time: string
    check_out_time: string | null
    check_out_type: string | null
    duration_minutes: number | null
  }[]
}

async function fetchWorkerShifts(
  workerId: string,
  dateFrom: Date,
  dateTo: Date
): Promise<ShiftWithParticipant[]> {
  const { data, error } = await supabase
    .from('shifts')
    .select(`
      id,
      participant_id,
      worker_id,
      scheduled_date,
      scheduled_start,
      scheduled_end,
      support_type,
      status,
      notes,
      participant:participants!participant_id (
        id, first_name, last_name, address, latitude, longitude,
        medical_alerts, special_instructions
      ),
      shift_check_ins (
        id, check_in_time, check_out_time, check_out_type, duration_minutes
      )
    `)
    .eq('worker_id', workerId)
    .gte('scheduled_date', dateFrom.toISOString().split('T')[0])
    .lte('scheduled_date', dateTo.toISOString().split('T')[0])
    .neq('status', 'cancelled')
    .order('scheduled_start', { ascending: true }) as any

  if (error) throw error
  return (data ?? []) as ShiftWithParticipant[]
}

export function useTodayShifts(workerId: string | null) {
  const today = new Date()
  return useQuery({
    queryKey: ['shifts', 'today', workerId, today.toISOString().split('T')[0]],
    queryFn: () => fetchWorkerShifts(workerId!, startOfDay(today), endOfDay(today)),
    enabled: !!workerId,
    staleTime: 1000 * 60 * 2, // 2 min stale
  })
}

export function useWeekShifts(workerId: string | null, weekStart?: Date) {
  const start = weekStart ?? startOfWeek(new Date(), { weekStartsOn: 1 })
  const end = endOfWeek(start, { weekStartsOn: 1 })
  return useQuery({
    queryKey: ['shifts', 'week', workerId, start.toISOString().split('T')[0]],
    queryFn: () => fetchWorkerShifts(workerId!, start, end),
    enabled: !!workerId,
    staleTime: 1000 * 60 * 5, // 5 min stale
  })
}

export function useShiftDetail(shiftId: string | null) {
  return useQuery({
    queryKey: ['shift', shiftId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('shifts')
        .select(`
          id, participant_id, worker_id, scheduled_date, scheduled_start, scheduled_end,
          support_type, status, notes,
          participant:participants!participant_id (
            id, first_name, last_name, address, latitude, longitude,
            medical_alerts, special_instructions, phone
          ),
          shift_check_ins (
            id, check_in_time, check_out_time, check_out_type, duration_minutes,
            check_in_latitude, check_in_longitude
          )
        `)
        .eq('id', shiftId!)
        .single() as any
      if (error) throw error
      return data as ShiftWithParticipant
    },
    enabled: !!shiftId,
  })
}
```

Key points:
- Uses `as any` for PostgREST join query (established pattern from Phases 3-4)
- Joins participants table for name + lat/lon + alerts
- Joins shift_check_ins for check-in status
- Filters out cancelled shifts
- Orders by scheduled_start ascending
- `useTodayShifts` and `useWeekShifts` take workerId (from useSession)
- `useShiftDetail` for the shift/[id] detail page
- staleTime is short (2-5 min) for fresh shift data
  </action>
  <verify>`grep -n "export function" apps/worker-mobile/hooks/useShifts.ts` shows useTodayShifts, useWeekShifts, useShiftDetail</verify>
  <done>Three query hooks exported: useTodayShifts (today's shifts for worker), useWeekShifts (week view), useShiftDetail (single shift with participant + check-in data).</done>
</task>

<task type="auto">
  <name>Task 2: Zustand stores and proximity utility</name>
  <files>apps/worker-mobile/stores/shiftStore.ts, apps/worker-mobile/stores/syncStore.ts, apps/worker-mobile/lib/proximity.ts</files>
  <action>
1. **Create stores/shiftStore.ts** -- active shift tracking:

```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import AsyncStorage from '@react-native-async-storage/async-storage'

interface ShiftStoreState {
  activeShiftId: string | null
  activeShiftStart: Date | null
  activeParticipantName: string | null
  setActiveShift: (shiftId: string, startTime: Date, participantName: string) => void
  clearActiveShift: () => void
}

export const useShiftStore = create<ShiftStoreState>()(
  persist(
    (set) => ({
      activeShiftId: null,
      activeShiftStart: null,
      activeParticipantName: null,
      setActiveShift: (shiftId, startTime, participantName) => set({
        activeShiftId: shiftId,
        activeShiftStart: startTime,
        activeParticipantName: participantName,
      }),
      clearActiveShift: () => set({
        activeShiftId: null,
        activeShiftStart: null,
        activeParticipantName: null,
      }),
    }),
    {
      name: 'active-shift',
      storage: createJSONStorage(() => AsyncStorage),
      // Custom serialization for Date objects
      partialize: (state) => ({
        activeShiftId: state.activeShiftId,
        activeShiftStart: state.activeShiftStart?.toISOString() ?? null,
        activeParticipantName: state.activeParticipantName,
      }),
      onRehydrateStorage: () => (state) => {
        if (state?.activeShiftStart && typeof state.activeShiftStart === 'string') {
          (state as any).activeShiftStart = new Date(state.activeShiftStart as any)
        }
      },
    }
  )
)
```

2. **Create stores/syncStore.ts** -- offline action queue (FIFO):

Follow the exact pattern from 05-RESEARCH.md Pattern 5 (Offline Check-in with Sync Queue). Use the interface and implementation from the research document. Key additions:
- Include `uuid` generation using `Math.random().toString(36)` (avoid crypto.randomUUID which may not exist in React Native)
- Process queue in FIFO order (sequential, not parallel)

```typescript
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import AsyncStorage from '@react-native-async-storage/async-storage'

interface PendingAction {
  id: string
  type: 'check_in' | 'check_out'
  shiftId: string
  timestamp: string
  latitude: number
  longitude: number
  createdAt: string
}

interface SyncStoreState {
  pendingActions: PendingAction[]
  addPendingAction: (action: Omit<PendingAction, 'id' | 'createdAt'>) => void
  removePendingAction: (id: string) => void
  getPendingCount: () => number
}

function generateId(): string {
  return Date.now().toString(36) + Math.random().toString(36).slice(2)
}

export const useSyncStore = create<SyncStoreState>()(
  persist(
    (set, get) => ({
      pendingActions: [],
      addPendingAction: (action) => set((state) => ({
        pendingActions: [...state.pendingActions, {
          ...action,
          id: generateId(),
          createdAt: new Date().toISOString(),
        }],
      })),
      removePendingAction: (id) => set((state) => ({
        pendingActions: state.pendingActions.filter((a) => a.id !== id),
      })),
      getPendingCount: () => get().pendingActions.length,
    }),
    {
      name: 'sync-queue',
      storage: createJSONStorage(() => AsyncStorage),
    }
  )
)
```

3. **Create lib/proximity.ts** -- haversine distance:

Follow the exact implementation from 05-RESEARCH.md Pattern 3 (GPS Proximity Check with Haversine). Copy the `getDistanceMeters` and `isWithinRadius` functions verbatim from the research document.
  </action>
  <verify>Check all files exist: `ls apps/worker-mobile/stores/shiftStore.ts apps/worker-mobile/stores/syncStore.ts apps/worker-mobile/lib/proximity.ts` and verify exports: `grep "export" apps/worker-mobile/lib/proximity.ts`</verify>
  <done>shiftStore tracks active shift (persisted to AsyncStorage). syncStore queues offline actions (persisted, FIFO). proximity.ts exports getDistanceMeters + isWithinRadius with 500m default radius.</done>
</task>

</tasks>

<verification>
- `useTodayShifts` returns shifts for current date ordered by start time
- `useShiftStore` persists activeShiftId and activeShiftStart between app restarts
- `useSyncStore` persists pending actions to AsyncStorage
- `isWithinRadius(0, 0, 0, 0.004, 500)` returns { within: true, distance: ~445 }
- No runtime errors from zustand persist + AsyncStorage
</verification>

<success_criteria>
- Shift hooks fetch correct data shape with participant + check-in joins
- Active shift state survives app kill and restart
- Offline sync queue maintains FIFO order
- Haversine calculation returns correct distance for known coordinates
</success_criteria>

<output>
After completion, create `.planning/phases/05-worker-mobile-app/05-03-SUMMARY.md`
</output>
