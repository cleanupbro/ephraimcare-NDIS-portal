---
phase: 05-worker-mobile-app
plan: 09
type: execute
wave: 4
depends_on: ["05-03", "05-06"]
files_modified:
  - apps/worker-mobile/lib/notifications.ts
  - apps/worker-mobile/lib/sync.ts
  - apps/worker-mobile/hooks/useNotifications.ts
  - apps/worker-mobile/components/OfflineIndicator.tsx
  - apps/worker-mobile/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "App registers push notification token with Supabase on login"
    - "Offline check-in/out actions sync silently when connectivity returns"
    - "Sync processes queue in FIFO order (check-in before check-out)"
    - "Offline indicator shows when device has no network connection"
    - "TanStack Query data persists to AsyncStorage for offline viewing"
  artifacts:
    - path: "apps/worker-mobile/lib/notifications.ts"
      provides: "Push notification registration and permission handling"
      exports: ["registerForPushNotifications"]
    - path: "apps/worker-mobile/lib/sync.ts"
      provides: "Background sync logic for offline action queue"
      exports: ["syncPendingActions", "startSyncListener"]
    - path: "apps/worker-mobile/hooks/useNotifications.ts"
      provides: "Hook for notification registration on login"
      exports: ["useNotificationSetup"]
    - path: "apps/worker-mobile/components/OfflineIndicator.tsx"
      provides: "Visual indicator when device is offline"
      exports: ["OfflineIndicator"]
  key_links:
    - from: "apps/worker-mobile/lib/sync.ts"
      to: "apps/worker-mobile/stores/syncStore.ts"
      via: "reads pendingActions, calls removePendingAction after success"
      pattern: "useSyncStore\\.getState"
    - from: "apps/worker-mobile/lib/notifications.ts"
      to: "supabase worker_push_tokens table"
      via: "upsert token on registration"
      pattern: "worker_push_tokens.*upsert"
    - from: "apps/worker-mobile/app/_layout.tsx"
      to: "apps/worker-mobile/lib/sync.ts"
      via: "startSyncListener on mount"
      pattern: "startSyncListener"
---

<objective>
Offline sync, push notification registration, offline indicator, and query persistence for the worker mobile app.

Purpose: Workers in the field may have intermittent connectivity. Offline check-in/out actions must sync silently when online (MOBL-09). Push notifications enable shift reminders (preparation for MOBL-10 auto-checkout warning). Query persistence caches today's shifts for offline viewing.

Output: Sync engine, push notification registration, offline indicator component, TanStack Query persistence setup.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-worker-mobile-app/05-RESEARCH.md
@apps/worker-mobile/stores/syncStore.ts
@apps/worker-mobile/lib/supabase.ts
@apps/worker-mobile/app/_layout.tsx
@apps/worker-mobile/constants/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Push notifications and sync engine</name>
  <files>apps/worker-mobile/lib/notifications.ts, apps/worker-mobile/lib/sync.ts, apps/worker-mobile/hooks/useNotifications.ts</files>
  <action>
1. **Create lib/notifications.ts:**

Follow the exact implementation from 05-RESEARCH.md Pattern 6 (Push Notification Registration). Copy the full `registerForPushNotifications` function. Key additions:
- Set notification handler with `shouldShowBanner: true, shouldShowList: true` (SDK 53 API, not deprecated `shouldShowAlert`)
- Android notification channel named 'shifts' with HIGH importance
- Token upserted to worker_push_tokens table

2. **Create lib/sync.ts:**

Follow the pattern from 05-RESEARCH.md "Offline Sync Background Process" with these modifications:
- Use `@react-native-community/netinfo` for connectivity check
- Process FIFO (sequential, break on first failure)
- Also update shift status when syncing check-in (set to 'in_progress') or check-out (set to 'completed')
- Add `startSyncListener` function that subscribes to NetInfo and triggers sync on reconnect
- Add `stopSyncListener` for cleanup

```typescript
import NetInfo, { NetInfoSubscription } from '@react-native-community/netinfo'
import { useSyncStore } from '../stores/syncStore'
import { supabase } from './supabase'

let syncSubscription: NetInfoSubscription | null = null

export async function syncPendingActions(): Promise<void> {
  const state = await NetInfo.fetch()
  if (!state.isConnected) return

  const { pendingActions, removePendingAction } = useSyncStore.getState()
  if (pendingActions.length === 0) return

  for (const action of pendingActions) {
    try {
      if (action.type === 'check_in') {
        const { error } = await supabase.from('shift_check_ins').insert({
          shift_id: action.shiftId,
          check_in_time: action.timestamp,
          check_in_latitude: action.latitude,
          check_in_longitude: action.longitude,
          synced_from_offline: true,
        } as any)
        if (error) throw error

        // Also update shift status
        await supabase.from('shifts')
          .update({ status: 'in_progress' } as any)
          .eq('id', action.shiftId)

      } else if (action.type === 'check_out') {
        // Get check-in time for duration calc
        const { data: checkIn } = await supabase
          .from('shift_check_ins')
          .select('check_in_time')
          .eq('shift_id', action.shiftId)
          .single() as any

        const durationMinutes = checkIn?.check_in_time
          ? Math.round((new Date(action.timestamp).getTime() - new Date(checkIn.check_in_time).getTime()) / (1000 * 60))
          : null

        const { error } = await supabase.from('shift_check_ins')
          .update({
            check_out_time: action.timestamp,
            check_out_latitude: action.latitude,
            check_out_longitude: action.longitude,
            check_out_type: 'manual',
            duration_minutes: durationMinutes,
            synced_from_offline: true,
          } as any)
          .eq('shift_id', action.shiftId)
        if (error) throw error

        await supabase.from('shifts')
          .update({ status: 'completed' } as any)
          .eq('id', action.shiftId)
      }

      removePendingAction(action.id)
    } catch (error) {
      console.warn('Sync failed for action:', action.id, error)
      break // Stop on failure to maintain FIFO order
    }
  }
}

export function startSyncListener(): void {
  if (syncSubscription) return // Already listening

  syncSubscription = NetInfo.addEventListener((state) => {
    if (state.isConnected) {
      // Silently sync when back online
      syncPendingActions()
    }
  })
}

export function stopSyncListener(): void {
  if (syncSubscription) {
    syncSubscription()
    syncSubscription = null
  }
}
```

3. **Create hooks/useNotifications.ts:**

```typescript
import { useEffect } from 'react'
import { registerForPushNotifications } from '../lib/notifications'
import { useSession } from './useAuth'

export function useNotificationSetup() {
  const { userId } = useSession()

  useEffect(() => {
    if (!userId) return

    // Register push token after login
    registerForPushNotifications(userId).catch((err) => {
      console.warn('Push notification registration failed:', err)
    })
  }, [userId])
}
```
  </action>
  <verify>Check exports: `grep "export" apps/worker-mobile/lib/notifications.ts apps/worker-mobile/lib/sync.ts apps/worker-mobile/hooks/useNotifications.ts`</verify>
  <done>Notifications register push token on login, upsert to worker_push_tokens. Sync processes offline queue FIFO, updates shift status, breaks on failure. Sync listener auto-triggers when connectivity returns. useNotificationSetup registers on userId change.</done>
</task>

<task type="auto">
  <name>Task 2: Offline indicator and query persistence integration</name>
  <files>apps/worker-mobile/components/OfflineIndicator.tsx, apps/worker-mobile/app/_layout.tsx</files>
  <action>
1. **Create components/OfflineIndicator.tsx:**

A small banner shown at top when device is offline:

```typescript
import { useEffect, useState } from 'react'
import { View } from 'react-native'
import { Text } from 'react-native-paper'
import NetInfo from '@react-native-community/netinfo'

export function OfflineIndicator() {
  const [isOffline, setIsOffline] = useState(false)

  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener((state) => {
      setIsOffline(!state.isConnected)
    })
    return () => unsubscribe()
  }, [])

  if (!isOffline) return null

  return (
    <View style={{
      backgroundColor: '#FFA726',
      paddingVertical: 4,
      paddingHorizontal: 16,
      alignItems: 'center',
    }}>
      <Text variant="labelSmall" style={{ color: '#fff' }}>
        No internet connection - changes will sync when online
      </Text>
    </View>
  )
}
```

2. **Update app/_layout.tsx** to integrate:
- Add TanStack Query persistence with AsyncStorage
- Start sync listener on mount
- Add OfflineIndicator
- Add useNotificationSetup call

Updated structure for the root layout:

```typescript
import { useEffect } from 'react'
import { View } from 'react-native'
import { Stack } from 'expo-router'
import { SessionProvider, useSession } from '../hooks/useAuth'
import { QueryClient } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QUERY_GC_TIME_MS } from '../constants/config'
import { ActivityIndicator } from 'react-native'
import { OfflineIndicator } from '../components/OfflineIndicator'
import { startSyncListener, stopSyncListener } from '../lib/sync'
import { useNotificationSetup } from '../hooks/useNotifications'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: QUERY_GC_TIME_MS, // 24 hours
      staleTime: 1000 * 60 * 5,
      retry: 2,
    },
  },
})

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'EPHRAIMCARE_QUERY_CACHE',
})

function RootNavigator() {
  const { session, isLoading } = useSession()
  useNotificationSetup()

  // Start sync listener when authenticated
  useEffect(() => {
    if (session) {
      startSyncListener()
      return () => stopSyncListener()
    }
  }, [session])

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#66BB6A" />
      </View>
    )
  }

  return (
    <View style={{ flex: 1 }}>
      <OfflineIndicator />
      <Stack screenOptions={{ headerShown: false }}>
        {session ? (
          <>
            <Stack.Screen name="(tabs)" />
            <Stack.Screen name="shift/[id]" options={{ presentation: 'card' }} />
          </>
        ) : (
          <Stack.Screen name="login" />
        )}
      </Stack>
    </View>
  )
}

export default function RootLayout() {
  return (
    <SessionProvider>
      <PersistQueryClientProvider
        client={queryClient}
        persistOptions={{
          persister: asyncStoragePersister,
          maxAge: QUERY_GC_TIME_MS,
        }}
      >
        <RootNavigator />
      </PersistQueryClientProvider>
    </SessionProvider>
  )
}
```

Key points:
- Replace QueryClientProvider with PersistQueryClientProvider (wraps with persistence)
- AsyncStorage persister saves query cache to disk (survives app kill)
- maxAge matches gcTime (24 hours) so cache and persister align
- Sync listener starts on auth, stops on unmount
- OfflineIndicator above Stack shows amber banner when offline
- useNotificationSetup registers push token on login
- QUERY_CACHE key prevents collision with other AsyncStorage data
  </action>
  <verify>Check: `grep "PersistQueryClientProvider\|startSyncListener\|OfflineIndicator\|useNotificationSetup" apps/worker-mobile/app/_layout.tsx`</verify>
  <done>Root layout uses PersistQueryClientProvider for offline query caching. Sync listener auto-triggers on reconnect. Offline banner shown when disconnected. Push notifications registered on login. Cache persists 24 hours.</done>
</task>

</tasks>

<verification>
- PersistQueryClientProvider wraps app (not plain QueryClientProvider)
- AsyncStorage persister configured with EPHRAIMCARE_QUERY_CACHE key
- Sync listener fires syncPendingActions on NetInfo 'connected' event
- Offline indicator shows amber banner when isConnected === false
- Push notification registration runs after login (userId available)
- Sync processes check_in before check_out (FIFO ordering maintained)
- Cache maxAge and gcTime both set to 24 hours
</verification>

<success_criteria>
- App caches today's shifts for offline viewing (MOBL-09)
- Offline check-in/out actions sync when connectivity returns (silent, no toast)
- Push token registered in worker_push_tokens table after login
- Worker sees amber "No internet" banner when offline
- Cache survives app kill and restart (24-hour retention)
</success_criteria>

<output>
After completion, create `.planning/phases/05-worker-mobile-app/05-09-SUMMARY.md`
</output>
