---
phase: 05-worker-mobile-app
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/worker-mobile/hooks/useAuth.tsx
  - apps/worker-mobile/app/_layout.tsx
  - apps/worker-mobile/app/login.tsx
autonomous: true

must_haves:
  truths:
    - "Worker can log in with email and password and see the tabs screen"
    - "Worker session persists between app closes without re-login"
    - "Unauthenticated user sees login screen, authenticated user sees tabs"
    - "Worker can log out from the app"
  artifacts:
    - path: "apps/worker-mobile/hooks/useAuth.tsx"
      provides: "SessionProvider context, useSession hook with session/isLoading/signIn/signOut"
      exports: ["SessionProvider", "useSession"]
    - path: "apps/worker-mobile/app/_layout.tsx"
      provides: "Root layout with SessionProvider, QueryClientProvider, and auth-gated navigation"
      contains: "SessionProvider"
    - path: "apps/worker-mobile/app/login.tsx"
      provides: "Login form with email/password fields and error display"
      contains: "signInWithPassword"
  key_links:
    - from: "apps/worker-mobile/hooks/useAuth.tsx"
      to: "apps/worker-mobile/lib/supabase.ts"
      via: "supabase.auth.onAuthStateChange"
      pattern: "onAuthStateChange"
    - from: "apps/worker-mobile/app/_layout.tsx"
      to: "apps/worker-mobile/hooks/useAuth.tsx"
      via: "SessionProvider wrapping + useSession guard"
      pattern: "SessionProvider"
---

<objective>
Auth system with persistent sessions and login UI for the worker mobile app.

Purpose: Workers must authenticate to access shifts. The session must persist indefinitely between app closes (via expo-sqlite localStorage) so workers never re-login unless they explicitly log out. This is the gateway to all protected functionality.

Output: SessionProvider hook, root layout with auth gating, functional login screen with email/password.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-worker-mobile-app/05-RESEARCH.md
@apps/worker-mobile/lib/supabase.ts
@apps/worker-mobile/app/_layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auth context with SessionProvider and useSession hook</name>
  <files>apps/worker-mobile/hooks/useAuth.tsx</files>
  <action>
Create a React context-based auth provider:

```typescript
// hooks/useAuth.tsx
import { createContext, useContext, useEffect, useState, PropsWithChildren } from 'react'
import { Session } from '@supabase/supabase-js'
import { supabase } from '../lib/supabase'

interface AuthContextType {
  session: Session | null
  isLoading: boolean
  signIn: (email: string, password: string) => Promise<{ error: string | null }>
  signOut: () => Promise<void>
  userId: string | null
}

const AuthContext = createContext<AuthContextType | null>(null)

export function SessionProvider({ children }: PropsWithChildren) {
  const [session, setSession] = useState<Session | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    // Get initial session from storage
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setIsLoading(false)
    })

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({ email, password })
    return { error: error?.message ?? null }
  }

  const signOut = async () => {
    await supabase.auth.signOut()
  }

  return (
    <AuthContext.Provider value={{
      session,
      isLoading,
      signIn,
      signOut,
      userId: session?.user?.id ?? null,
    }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useSession() {
  const context = useContext(AuthContext)
  if (!context) throw new Error('useSession must be inside SessionProvider')
  return context
}
```

Key points:
- `getSession()` loads persisted session from expo-sqlite localStorage on mount
- `onAuthStateChange` keeps state synced with token refresh
- `signIn` returns error string (null on success) for form display
- `signOut` clears session (supabase handles localStorage cleanup)
- `isLoading` true until initial session check completes (prevents flash)
  </action>
  <verify>Check file exists and exports: `grep -n "export" apps/worker-mobile/hooks/useAuth.tsx`</verify>
  <done>SessionProvider wraps app providing session state. useSession hook returns session, isLoading, signIn, signOut, userId. Session auto-loads from localStorage on mount.</done>
</task>

<task type="auto">
  <name>Task 2: Root layout with auth gating and login screen</name>
  <files>apps/worker-mobile/app/_layout.tsx, apps/worker-mobile/app/login.tsx</files>
  <action>
1. **Replace app/_layout.tsx** with auth-gated navigation:

Use the Redirect fallback pattern (more stable than Stack.Protected per research pitfall #7):

```typescript
// app/_layout.tsx
import { Stack, Redirect } from 'expo-router'
import { SessionProvider, useSession } from '../hooks/useAuth'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { QUERY_GC_TIME_MS } from '../constants/config'
import { View, ActivityIndicator } from 'react-native'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: QUERY_GC_TIME_MS,
      staleTime: 1000 * 60 * 5, // 5 min stale
      retry: 2,
    },
  },
})

function RootNavigator() {
  const { session, isLoading } = useSession()

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#66BB6A" />
      </View>
    )
  }

  return (
    <Stack screenOptions={{ headerShown: false }}>
      {session ? (
        <>
          <Stack.Screen name="(tabs)" />
          <Stack.Screen name="shift/[id]" options={{ presentation: 'card' }} />
        </>
      ) : (
        <Stack.Screen name="login" />
      )}
    </Stack>
  )
}

export default function RootLayout() {
  return (
    <SessionProvider>
      <QueryClientProvider client={queryClient}>
        <RootNavigator />
      </QueryClientProvider>
    </SessionProvider>
  )
}
```

2. **Replace app/login.tsx** with functional login form:

```typescript
// app/login.tsx
import { useState } from 'react'
import { View, KeyboardAvoidingView, Platform } from 'react-native'
import { TextInput, Button, Text, HelperText } from 'react-native-paper'
import { useSession } from '../hooks/useAuth'

export default function LoginScreen() {
  const { signIn } = useSession()
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const [showPassword, setShowPassword] = useState(false)

  const handleLogin = async () => {
    if (!email.trim() || !password.trim()) {
      setError('Email and password are required')
      return
    }
    setError(null)
    setLoading(true)
    const { error: signInError } = await signIn(email.trim(), password)
    if (signInError) setError(signInError)
    setLoading(false)
  }

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
    >
      <View style={{ flex: 1, justifyContent: 'center', padding: 24, backgroundColor: '#fff' }}>
        <Text variant="headlineMedium" style={{ textAlign: 'center', color: '#66BB6A', fontWeight: 'bold', marginBottom: 8 }}>
          Ephraim Care
        </Text>
        <Text variant="bodyMedium" style={{ textAlign: 'center', color: '#666', marginBottom: 32 }}>
          Worker App
        </Text>

        <TextInput
          label="Email"
          value={email}
          onChangeText={setEmail}
          keyboardType="email-address"
          autoCapitalize="none"
          autoComplete="email"
          mode="outlined"
          style={{ marginBottom: 16 }}
          outlineColor="#ccc"
          activeOutlineColor="#66BB6A"
        />

        <TextInput
          label="Password"
          value={password}
          onChangeText={setPassword}
          secureTextEntry={!showPassword}
          mode="outlined"
          style={{ marginBottom: 8 }}
          outlineColor="#ccc"
          activeOutlineColor="#66BB6A"
          right={
            <TextInput.Icon
              icon={showPassword ? 'eye-off' : 'eye'}
              onPress={() => setShowPassword(!showPassword)}
            />
          }
        />

        {error && (
          <HelperText type="error" visible={!!error} style={{ marginBottom: 8 }}>
            {error}
          </HelperText>
        )}

        <Button
          mode="contained"
          onPress={handleLogin}
          loading={loading}
          disabled={loading}
          style={{ marginTop: 16, borderRadius: 8 }}
          buttonColor="#66BB6A"
        >
          Sign In
        </Button>
      </View>
    </KeyboardAvoidingView>
  )
}
```

Key points:
- Use Redirect pattern in _layout (not Stack.Protected) to avoid SDK 53 issue #37305
- QueryClient configured with 24h gcTime for offline cache preservation
- Login uses react-native-paper components for Material Design consistency
- KeyboardAvoidingView for iOS keyboard handling
- Show/hide password toggle
- Loading state on button during signIn
  </action>
  <verify>Check files: `cat apps/worker-mobile/app/_layout.tsx | grep SessionProvider` and `cat apps/worker-mobile/app/login.tsx | grep signInWithPassword`</verify>
  <done>Root layout wraps app in SessionProvider + QueryClientProvider. Unauthenticated users see login form. Login submits email/password to Supabase. Session persists between app closes via localStorage. Loading spinner shown during session check.</done>
</task>

</tasks>

<verification>
- `useSession()` returns session, isLoading, signIn, signOut
- Root layout shows loading spinner -> login or tabs based on session
- Login form validates non-empty fields and displays Supabase auth errors
- QueryClient has gcTime of 24 hours
- No Stack.Protected used (Redirect fallback for stability)
</verification>

<success_criteria>
- Worker logs in with email/password and transitions to tabs screen
- Closing and reopening app keeps worker logged in (no re-login)
- Invalid credentials show clear error message on login screen
- signOut clears session and returns to login screen
</success_criteria>

<output>
After completion, create `.planning/phases/05-worker-mobile-app/05-02-SUMMARY.md`
</output>
