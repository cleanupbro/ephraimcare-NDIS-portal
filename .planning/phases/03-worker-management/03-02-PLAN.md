---
phase: 03-worker-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/admin/components/workers/worker-columns.tsx
  - apps/admin/components/workers/worker-search.tsx
  - apps/admin/components/workers/worker-list.tsx
  - apps/admin/hooks/use-workers.ts
  - apps/admin/app/(protected)/workers/page.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can see a table of all workers with Name, Email, Support Types, Status, and Hours This Week columns"
    - "Admin can search workers by name or email with instant filtering"
    - "Admin can filter workers by status (active, inactive, all)"
    - "Each worker row shows a compliance traffic light dot (green/amber/red)"
  artifacts:
    - path: "apps/admin/components/workers/worker-columns.tsx"
      provides: "DataTable column definitions for worker list"
      exports: ["workerColumns"]
    - path: "apps/admin/components/workers/worker-search.tsx"
      provides: "Search input and status filter for worker list"
      exports: ["WorkerSearch"]
    - path: "apps/admin/components/workers/worker-list.tsx"
      provides: "Client component with DataTable and search state"
      exports: ["WorkerList"]
    - path: "apps/admin/hooks/use-workers.ts"
      provides: "TanStack Query hook for fetching workers with search/filter"
      exports: ["useWorkers"]
    - path: "apps/admin/app/(protected)/workers/page.tsx"
      provides: "Server component page with initial data fetch"
      min_lines: 15
  key_links:
    - from: "apps/admin/app/(protected)/workers/page.tsx"
      to: "supabase workers table"
      via: "server-side createClient query with profile join"
      pattern: "from.*workers.*select.*profiles"
    - from: "apps/admin/components/workers/worker-list.tsx"
      to: "apps/admin/hooks/use-workers.ts"
      via: "useWorkers hook for client-side queries"
      pattern: "useWorkers"
    - from: "apps/admin/components/workers/worker-columns.tsx"
      to: "apps/admin/lib/workers/constants.ts"
      via: "getOverallComplianceStatus for traffic light dot"
      pattern: "getOverallComplianceStatus"
---

<objective>
Build the worker list page with DataTable, search by name/email, status filter, and compliance traffic light dot — matching the participant list page pattern exactly.

Purpose: WORK-01 requires admin to view all workers with search and filter. This page is the primary navigation entry point for worker management.
Output: Fully functional /workers page with table, search, filter, and compliance indicators.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-worker-management/03-RESEARCH.md
@.planning/phases/03-worker-management/03-01-SUMMARY.md

# Pattern reference — participant list implementation
@apps/admin/components/participants/participant-columns.tsx
@apps/admin/components/participants/participant-list.tsx
@apps/admin/components/participants/participant-search.tsx
@apps/admin/hooks/use-participants.ts
@apps/admin/app/(protected)/participants/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Worker columns and compliance dot</name>
  <files>apps/admin/components/workers/worker-columns.tsx</files>
  <action>
Create column definitions for the DataTable following the participant-columns.tsx pattern:

Columns (in order):
1. **Name** — `profiles.first_name + ' ' + profiles.last_name`. Sortable. Clicking row navigates to /workers/[id].
2. **Email** — `profiles.email`. Truncated with ellipsis if too long.
3. **Support Types** — `services_provided` array rendered as up to 2 Badge components (secondary variant). If more than 2, show "+N more" badge.
4. **Status** — Compliance traffic light dot using `getOverallComplianceStatus(row.ndis_check_expiry, row.wwcc_expiry)`. Render a 10px (h-2.5 w-2.5) colored circle span with tooltip showing the status text.
5. **Hours This Week** — Placeholder showing "—" for now (will be populated when shifts exist). Format as "X.X hrs" when available.
6. **Actions** — DropdownMenu with "View" (navigates to /workers/[id]) and "Edit" (navigates to /workers/[id]/edit) options.

Import `getOverallComplianceStatus` and `COMPLIANCE_COLORS` from `@/lib/workers/constants`.
Import `WorkerWithProfile` from `@ephraimcare/types` (or from the domain types file).
Use Next.js `Link` for navigation, not onClick handlers.
  </action>
  <verify>File compiles without TypeScript errors. All 6 columns defined. Compliance dot uses getOverallComplianceStatus.</verify>
  <done>Worker columns render name, email, support type badges, compliance dot, hours placeholder, and action menu for each worker row.</done>
</task>

<task type="auto">
  <name>Task 2: Worker search bar, list component, and query hook</name>
  <files>apps/admin/components/workers/worker-search.tsx, apps/admin/components/workers/worker-list.tsx, apps/admin/hooks/use-workers.ts</files>
  <action>
**use-workers.ts:** Create TanStack Query hook following use-participants.ts pattern:
- `useWorkers({ search, status })` — queries workers table with profile join
- Query: `.from('workers').select('*, profiles!inner(first_name, last_name, email, phone)')`
- If status is 'active': `.eq('is_active', true)`. If 'inactive': `.eq('is_active', false)`. If 'all': no filter.
- For search: Apply `.or()` filter on the query. Since PostgREST .or() with joined tables has limitations, implement search by filtering client-side on the returned data: `data.filter(w => name includes search OR email includes search)`. This is the safe fallback approach per research.
- Order by `created_at` desc (newest first).
- queryKey: `['workers', search, status]`
- Use `createClient` from `@/lib/supabase/client` (browser client).

**worker-search.tsx:** Create search + filter bar matching participant-search.tsx pattern:
- Search Input with Search icon (lucide-react), placeholder "Search by name or email..."
- Status Select (shadcn Select component) with options: "Active" (default), "Inactive", "All"
- "Add Worker" Button (Plus icon) that links to /workers/new
- Layout: flex row, search input takes flex-1, select is fixed width, button on right

**worker-list.tsx:** Create client component matching participant-list.tsx pattern:
- Props: `{ initialData: WorkerWithProfile[] }`
- State: search (string), status ('active' | 'inactive' | 'all')
- Use `useDeferredValue` for search (React 19 pattern)
- Call `useWorkers({ search: deferredSearch, status })`
- Display data: `workers ?? initialData ?? []`
- Client-side search filter: filter displayData where full name or email includes the deferred search term (case-insensitive)
- Render `<WorkerSearch>` and `<DataTable columns={workerColumns} data={filteredData} />`
- Show loading skeleton while `isLoading` and no initialData available
  </action>
  <verify>TypeScript compiles. WorkerList renders DataTable with workerColumns. useWorkers returns query with correct queryKey. Search filters by name/email. Status filter uses is_active column.</verify>
  <done>Worker list shows all workers in a table with real-time search filtering by name/email and status dropdown filter. Add Worker button navigates to /workers/new.</done>
</task>

<task type="auto">
  <name>Task 3: Worker list server page</name>
  <files>apps/admin/app/(protected)/workers/page.tsx</files>
  <action>
Create the server component page matching participants/page.tsx pattern:

```typescript
import { createClient } from '@/lib/supabase/server'
import { WorkerList } from '@/components/workers/worker-list'

export const metadata = { title: 'Workers | Ephraim Care' }

export default async function WorkersPage() {
  const supabase = await createClient()
  const { data } = await supabase
    .from('workers')
    .select('*, profiles!inner(first_name, last_name, email, phone)')
    .eq('is_active', true)
    .order('created_at', { ascending: false })

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold tracking-tight">Workers</h1>
        <p className="text-muted-foreground">Manage your support workers and their qualifications.</p>
      </div>
      <WorkerList initialData={(data as any) ?? []} />
    </div>
  )
}
```

Use `(data as any)` type assertion for the PostgREST joined query result (same pattern as participants).
  </action>
  <verify>Page renders at /workers with initial worker data. No TypeScript errors. Server component fetches active workers with profile join on load.</verify>
  <done>Visiting /workers shows the worker list page with heading, description, and DataTable populated from server-side fetch.</done>
</task>

</tasks>

<verification>
1. /workers page loads with "Workers" heading and DataTable
2. Table shows columns: Name, Email, Support Types, Status (dot), Hours This Week, Actions
3. Search input filters workers by name or email (case-insensitive)
4. Status dropdown filters by active/inactive/all
5. Compliance dot shows correct color based on check expiry dates
6. "Add Worker" button navigates to /workers/new
7. Actions dropdown has "View" and "Edit" options with correct links
</verification>

<success_criteria>
- Worker list page accessible at /workers route
- DataTable reuses the shared DataTable component from Phase 2
- Search works across both name (first + last) and email
- Compliance dot correctly shows green/amber/red/gray based on expiry dates
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-worker-management/03-02-SUMMARY.md`
</output>
