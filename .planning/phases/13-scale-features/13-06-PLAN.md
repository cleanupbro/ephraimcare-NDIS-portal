---
phase: 13-scale-features
plan: 06
type: execute
wave: 2
depends_on: ["13-03"]
files_modified:
  - apps/admin/package.json
  - apps/admin/app/api/xero/connect/route.ts
  - apps/admin/app/api/xero/callback/route.ts
  - apps/admin/app/api/xero/disconnect/route.ts
  - apps/admin/lib/xero/client.ts
autonomous: true

user_setup:
  - service: xero
    why: "Automatic invoice sync to accounting software"
    env_vars:
      - name: XERO_CLIENT_ID
        source: "Xero Developer Portal -> My Apps -> OAuth 2.0 credentials"
      - name: XERO_CLIENT_SECRET
        source: "Xero Developer Portal -> My Apps -> OAuth 2.0 credentials"
    dashboard_config:
      - task: "Create OAuth 2.0 app"
        location: "https://developer.xero.com/myapps"
      - task: "Add redirect URI"
        location: "App settings -> Redirect URIs: https://your-domain/api/xero/callback"

must_haves:
  truths:
    - "Admin can click Connect to Xero and be redirected to Xero consent"
    - "After Xero approval, callback stores tokens in organization"
    - "xero_connected flag is set to true in organization settings"
    - "Admin can disconnect Xero and tokens are cleared"
  artifacts:
    - path: "apps/admin/app/api/xero/connect/route.ts"
      provides: "OAuth2 authorization URL redirect"
      exports: ["GET"]
    - path: "apps/admin/app/api/xero/callback/route.ts"
      provides: "OAuth2 callback handler"
      exports: ["GET"]
    - path: "apps/admin/lib/xero/client.ts"
      provides: "Xero client factory with token refresh"
      exports: ["getXeroClient"]
  key_links:
    - from: "apps/admin/app/api/xero/callback/route.ts"
      to: "organizations.xero_token_set"
      via: "Supabase update"
      pattern: "xero_token_set"
---

<objective>
Create the Xero OAuth2 connection flow for automatic invoice syncing.

Purpose: Allow organizations to connect their Xero account for automatic invoice creation when invoices are finalized.

Output: OAuth2 connect/callback/disconnect routes, Xero client factory with token refresh.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-scale-features/13-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Xero SDK</name>
  <files>apps/admin/package.json</files>
  <action>
Add Xero Node SDK to admin app:

```bash
cd /Users/shamalkrishna/Desktop/ephraimcare-portal-2026/apps/admin
pnpm add xero-node
```

This installs the official Xero SDK with OAuth2 support and typed responses.
  </action>
  <verify>
`pnpm list xero-node` shows xero-node installed.
  </verify>
  <done>
Xero SDK available for OAuth2 and invoice operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Xero OAuth2 connect endpoint</name>
  <files>apps/admin/app/api/xero/connect/route.ts</files>
  <action>
Create the OAuth2 authorization URL redirect:

```typescript
import { NextResponse } from 'next/server'
import { XeroClient } from 'xero-node'
import { createClient } from '@/lib/supabase/server'

/**
 * Start Xero OAuth2 flow
 * GET /api/xero/connect
 */
export async function GET() {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.redirect(new URL('/login', process.env.NEXT_PUBLIC_ADMIN_URL))
    }

    // Get user's profile
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id || profile.role !== 'admin') {
      return NextResponse.redirect(
        new URL('/settings/integrations?error=admin_required', process.env.NEXT_PUBLIC_ADMIN_URL)
      )
    }

    // Initialize Xero client
    const xero = new XeroClient({
      clientId: process.env.XERO_CLIENT_ID!,
      clientSecret: process.env.XERO_CLIENT_SECRET!,
      redirectUris: [`${process.env.NEXT_PUBLIC_ADMIN_URL}/api/xero/callback`],
      scopes: [
        'openid',
        'profile',
        'email',
        'accounting.transactions',
        'accounting.contacts',
        'offline_access', // Required for refresh tokens
      ],
    })

    // Store org ID in state for callback
    const state = Buffer.from(JSON.stringify({
      organizationId: profile.organization_id,
      timestamp: Date.now(),
    })).toString('base64url')

    // Generate consent URL
    const consentUrl = await xero.buildConsentUrl()

    // Append state to URL
    const url = new URL(consentUrl)
    url.searchParams.set('state', state)

    return NextResponse.redirect(url.toString())
  } catch (error) {
    console.error('Xero connect error:', error)
    return NextResponse.redirect(
      new URL('/settings/integrations?error=xero_connect_failed', process.env.NEXT_PUBLIC_ADMIN_URL)
    )
  }
}
```

Key features:
- Verifies admin role before OAuth
- Stores organization ID in state for callback
- Requests offline_access for refresh tokens
- Scopes for transactions and contacts
  </action>
  <verify>
Run `pnpm typecheck`. Route compiles.
  </verify>
  <done>
Connect endpoint initiates Xero OAuth2 flow with proper scopes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Xero OAuth2 callback handler</name>
  <files>apps/admin/app/api/xero/callback/route.ts</files>
  <action>
Create callback to handle OAuth2 response:

```typescript
import { NextResponse } from 'next/server'
import { XeroClient } from 'xero-node'
import { createClient } from '@supabase/supabase-js'

/**
 * Xero OAuth2 callback handler
 * GET /api/xero/callback?code=xxx&state=xxx
 */
export async function GET(request: Request) {
  const url = new URL(request.url)
  const code = url.searchParams.get('code')
  const state = url.searchParams.get('state')
  const error = url.searchParams.get('error')

  // Handle user cancellation or error
  if (error) {
    console.error('Xero OAuth error:', error)
    return NextResponse.redirect(
      new URL(`/settings/integrations?error=xero_denied`, process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  }

  if (!code || !state) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=invalid_callback', process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  }

  try {
    // Decode state to get organization ID
    const stateData = JSON.parse(Buffer.from(state, 'base64url').toString())
    const { organizationId, timestamp } = stateData

    // Validate timestamp (15 min expiry)
    if (Date.now() - timestamp > 15 * 60 * 1000) {
      return NextResponse.redirect(
        new URL('/settings/integrations?error=expired', process.env.NEXT_PUBLIC_ADMIN_URL!)
      )
    }

    // Initialize Xero client
    const xero = new XeroClient({
      clientId: process.env.XERO_CLIENT_ID!,
      clientSecret: process.env.XERO_CLIENT_SECRET!,
      redirectUris: [`${process.env.NEXT_PUBLIC_ADMIN_URL}/api/xero/callback`],
      scopes: [
        'openid',
        'profile',
        'email',
        'accounting.transactions',
        'accounting.contacts',
        'offline_access',
      ],
    })

    // Exchange code for tokens
    const tokenSet = await xero.apiCallback(url.toString())

    // Get connected Xero tenant (organization)
    await xero.updateTenants()
    const tenants = xero.tenants
    const activeTenant = tenants[0] // Use first tenant (most common case)

    if (!activeTenant) {
      return NextResponse.redirect(
        new URL('/settings/integrations?error=no_xero_org', process.env.NEXT_PUBLIC_ADMIN_URL!)
      )
    }

    // Store tokens in organization using service role
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Get existing settings to merge
    const { data: org } = await supabase
      .from('organizations')
      .select('settings')
      .eq('id', organizationId)
      .single()

    const currentSettings = org?.settings as Record<string, any> || {}

    await supabase
      .from('organizations')
      .update({
        xero_token_set: tokenSet,
        xero_tenant_id: activeTenant.tenantId,
        settings: {
          ...currentSettings,
          xero_connected: true,
          xero_org_name: activeTenant.tenantName,
        },
      } as any)
      .eq('id', organizationId)

    return NextResponse.redirect(
      new URL('/settings/integrations?success=xero_connected', process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  } catch (error) {
    console.error('Xero callback error:', error)
    return NextResponse.redirect(
      new URL('/settings/integrations?error=xero_callback_failed', process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  }
}
```

Key features:
- Validates state parameter with timestamp
- Exchanges authorization code for tokens
- Gets Xero tenant ID for API calls
- Stores tokens securely in organization
- Updates xero_connected flag
  </action>
  <verify>
Run `pnpm typecheck`. Callback compiles.
  </verify>
  <done>
Callback handler stores Xero tokens and tenant ID in organization.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Xero client factory and disconnect</name>
  <files>apps/admin/lib/xero/client.ts, apps/admin/app/api/xero/disconnect/route.ts</files>
  <action>
Create Xero client factory with token refresh:

```typescript
// apps/admin/lib/xero/client.ts
import { XeroClient, TokenSet } from 'xero-node'
import { createClient } from '@supabase/supabase-js'

/**
 * Get authenticated Xero client for an organization
 * Handles token refresh automatically
 */
export async function getXeroClient(organizationId: string): Promise<{
  client: XeroClient | null
  tenantId: string | null
  error?: string
}> {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  // Fetch org's Xero credentials
  const { data: org, error: orgError } = await supabase
    .from('organizations')
    .select('xero_token_set, xero_tenant_id, settings')
    .eq('id', organizationId)
    .single()

  if (orgError || !org) {
    return { client: null, tenantId: null, error: 'Organization not found' }
  }

  const settings = org.settings as { xero_connected?: boolean } | null
  if (!settings?.xero_connected) {
    return { client: null, tenantId: null, error: 'Xero not connected' }
  }

  if (!org.xero_token_set || !org.xero_tenant_id) {
    return { client: null, tenantId: null, error: 'Xero credentials missing' }
  }

  // Initialize Xero client
  const xero = new XeroClient({
    clientId: process.env.XERO_CLIENT_ID!,
    clientSecret: process.env.XERO_CLIENT_SECRET!,
    redirectUris: [`${process.env.NEXT_PUBLIC_ADMIN_URL}/api/xero/callback`],
    scopes: [
      'openid',
      'profile',
      'email',
      'accounting.transactions',
      'accounting.contacts',
      'offline_access',
    ],
  })

  await xero.initialize()

  // Set stored tokens
  const tokenSet = org.xero_token_set as TokenSet
  await xero.setTokenSet(tokenSet)

  // Check if token needs refresh (expires_at is in seconds)
  const expiresAt = tokenSet.expires_at || 0
  const nowInSeconds = Math.floor(Date.now() / 1000)
  const bufferSeconds = 60 // Refresh 1 minute before expiry

  if (expiresAt - nowInSeconds < bufferSeconds) {
    try {
      const newTokenSet = await xero.refreshToken()

      // Store refreshed tokens
      await supabase
        .from('organizations')
        .update({ xero_token_set: newTokenSet } as any)
        .eq('id', organizationId)

      console.log('Xero token refreshed for org:', organizationId)
    } catch (refreshError) {
      console.error('Xero token refresh failed:', refreshError)
      // Clear connection on refresh failure
      const currentSettings = org.settings as Record<string, any> || {}
      await supabase
        .from('organizations')
        .update({
          xero_token_set: null,
          xero_tenant_id: null,
          settings: { ...currentSettings, xero_connected: false },
        } as any)
        .eq('id', organizationId)

      return { client: null, tenantId: null, error: 'Xero connection expired. Please reconnect.' }
    }
  }

  return { client: xero, tenantId: org.xero_tenant_id }
}
```

Create disconnect endpoint:

```typescript
// apps/admin/app/api/xero/disconnect/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createClient as createServiceClient } from '@supabase/supabase-js'

/**
 * Disconnect Xero from organization
 * GET /api/xero/disconnect
 */
export async function GET() {
  try {
    const supabase = await createClient()

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.redirect(new URL('/login', process.env.NEXT_PUBLIC_ADMIN_URL))
    }

    // Get user's profile
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id || profile.role !== 'admin') {
      return NextResponse.redirect(
        new URL('/settings/integrations?error=admin_required', process.env.NEXT_PUBLIC_ADMIN_URL)
      )
    }

    // Clear Xero credentials using service role
    const serviceClient = createServiceClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Get current settings
    const { data: org } = await serviceClient
      .from('organizations')
      .select('settings')
      .eq('id', profile.organization_id)
      .single()

    const currentSettings = org?.settings as Record<string, any> || {}

    await serviceClient
      .from('organizations')
      .update({
        xero_token_set: null,
        xero_tenant_id: null,
        settings: {
          ...currentSettings,
          xero_connected: false,
          xero_org_name: null,
        },
      } as any)
      .eq('id', profile.organization_id)

    return NextResponse.redirect(
      new URL('/settings/integrations?success=xero_disconnected', process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  } catch (error) {
    console.error('Xero disconnect error:', error)
    return NextResponse.redirect(
      new URL('/settings/integrations?error=disconnect_failed', process.env.NEXT_PUBLIC_ADMIN_URL!)
    )
  }
}
```
  </action>
  <verify>
Run `pnpm typecheck`. All files compile.
  </verify>
  <done>
Xero client factory with auto-refresh and disconnect endpoint created.
  </done>
</task>

</tasks>

<verification>
1. /api/xero/connect redirects to Xero consent page
2. After Xero approval, callback stores tokens and redirects to integrations page
3. xero_connected = true in organization settings after connection
4. getXeroClient returns authenticated client
5. /api/xero/disconnect clears tokens and sets xero_connected = false
</verification>

<success_criteria>
- Connect endpoint initiates OAuth2 with correct scopes
- Callback stores tokens and tenant ID securely
- Token refresh happens automatically before expiry
- Disconnect clears all Xero credentials
- Settings page shows connected status
</success_criteria>

<output>
After completion, create `.planning/phases/13-scale-features/13-06-SUMMARY.md`
</output>
