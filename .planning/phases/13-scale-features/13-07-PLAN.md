---
phase: 13-scale-features
plan: 07
type: execute
wave: 3
depends_on: ["13-06"]
files_modified:
  - apps/admin/lib/xero/sync-invoice.ts
  - apps/admin/app/api/invoices/[id]/finalize/route.ts
  - packages/types/src/database.ts
autonomous: true

must_haves:
  truths:
    - "When invoice is finalized, Xero invoice is created automatically if Xero is connected"
    - "Participant is mapped to Xero contact (created if not exists)"
    - "Invoice line items are mapped to Xero line items with correct amounts"
    - "Xero invoice ID is stored in invoice record for reconciliation"
    - "Sync failure does not block invoice finalization (logs error, continues)"
  artifacts:
    - path: "apps/admin/lib/xero/sync-invoice.ts"
      provides: "Invoice sync to Xero function"
      exports: ["syncInvoiceToXero"]
    - path: "apps/admin/app/api/invoices/[id]/finalize/route.ts"
      provides: "Invoice finalize endpoint with Xero sync"
      contains: "syncInvoiceToXero"
  key_links:
    - from: "apps/admin/lib/xero/sync-invoice.ts"
      to: "getXeroClient"
      via: "function call"
      pattern: "getXeroClient"
---

<objective>
Implement automatic Xero invoice sync when invoices are finalized.

Purpose: Reduce manual data entry by automatically creating invoices in Xero when they are finalized in the platform, keeping accounting records in sync.

Output: Invoice sync function, updated finalize endpoint that triggers sync, contact mapping.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-scale-features/13-RESEARCH.md
@.planning/phases/13-scale-features/13-06-PLAN.md

# Existing invoice patterns
@apps/admin/hooks/use-invoices.ts
@apps/admin/lib/invoices/generate-invoice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Xero invoice ID column to invoices table</name>
  <files>supabase/migrations/20260127000004_xero_invoice_tracking.sql</files>
  <action>
Create migration for Xero invoice tracking:

```sql
-- Xero invoice tracking for reconciliation

ALTER TABLE invoices
ADD COLUMN IF NOT EXISTS xero_invoice_id text,
ADD COLUMN IF NOT EXISTS xero_sync_status text DEFAULT 'pending'
  CHECK (xero_sync_status IN ('pending', 'synced', 'failed', 'not_applicable')),
ADD COLUMN IF NOT EXISTS xero_sync_error text,
ADD COLUMN IF NOT EXISTS xero_synced_at timestamptz;

-- Contact mapping for participants to Xero contacts
ALTER TABLE organizations
ADD COLUMN IF NOT EXISTS xero_contact_mapping jsonb DEFAULT '{}'::jsonb;

-- Index for finding unsynced invoices
CREATE INDEX IF NOT EXISTS idx_invoices_xero_sync
  ON invoices (organization_id, xero_sync_status)
  WHERE xero_sync_status = 'pending';

-- Comment
COMMENT ON COLUMN invoices.xero_invoice_id IS 'Xero invoice ID for reconciliation';
COMMENT ON COLUMN invoices.xero_sync_status IS 'Status of Xero sync: pending, synced, failed, not_applicable';
```

Key columns:
- xero_invoice_id: Links to Xero for reconciliation
- xero_sync_status: Track sync state
- xero_sync_error: Store failure reason for retry
- xero_contact_mapping: Cache participant-to-contact mapping
  </action>
  <verify>
Migration syntax is valid SQL.
  </verify>
  <done>
Invoices table extended with Xero tracking columns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Xero invoice sync function</name>
  <files>apps/admin/lib/xero/sync-invoice.ts</files>
  <action>
Create the sync function:

```typescript
import { getXeroClient } from './client'
import { createClient } from '@supabase/supabase-js'
import { Invoice as XeroInvoice, LineItem, Contact } from 'xero-node'

export interface SyncInvoiceResult {
  success: boolean
  xeroInvoiceId?: string
  error?: string
}

/**
 * Sync a finalized invoice to Xero
 * Creates contact if needed, then creates invoice
 */
export async function syncInvoiceToXero(invoiceId: string): Promise<SyncInvoiceResult> {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  // Fetch invoice with all details
  const { data: invoice, error: invoiceError } = await supabase
    .from('invoices')
    .select(`
      *,
      participant:participants(
        id,
        first_name,
        last_name,
        email,
        ndis_number
      ),
      line_items:invoice_line_items(
        id,
        description,
        quantity,
        unit_price,
        total,
        support_item_number
      )
    `)
    .eq('id', invoiceId)
    .single()

  if (invoiceError || !invoice) {
    return { success: false, error: 'Invoice not found' }
  }

  // Get Xero client
  const { client: xero, tenantId, error: clientError } = await getXeroClient(invoice.organization_id)

  if (!xero || !tenantId) {
    // Xero not connected - mark as not applicable
    await supabase
      .from('invoices')
      .update({
        xero_sync_status: 'not_applicable',
        xero_sync_error: clientError || 'Xero not connected',
      } as any)
      .eq('id', invoiceId)

    return { success: false, error: clientError || 'Xero not connected' }
  }

  try {
    // Get or create Xero contact for participant
    const contactId = await getOrCreateXeroContact(
      xero,
      tenantId,
      supabase,
      invoice.organization_id,
      invoice.participant
    )

    // Map line items
    const lineItems: LineItem[] = invoice.line_items.map((item: any) => ({
      description: item.description,
      quantity: item.quantity,
      unitAmount: item.unit_price,
      accountCode: '200', // Revenue account - TODO: make configurable
      taxType: 'EXEMPTOUTPUT', // NDIS is GST-free
      lineAmount: item.total,
      tracking: item.support_item_number ? [
        { name: 'NDIS Support Item', option: item.support_item_number }
      ] : undefined,
    }))

    // Create Xero invoice
    const xeroInvoice: XeroInvoice = {
      type: XeroInvoice.TypeEnum.ACCREC,
      contact: { contactID: contactId },
      lineItems,
      date: invoice.invoice_date,
      dueDate: invoice.due_date,
      reference: invoice.invoice_number,
      status: XeroInvoice.StatusEnum.AUTHORISED,
      lineAmountTypes: XeroInvoice.LineAmountTypesEnum.Exclusive,
    }

    const result = await xero.accountingApi.createInvoices(
      tenantId,
      { invoices: [xeroInvoice] }
    )

    const xeroInvoiceId = result.body.invoices?.[0]?.invoiceID

    if (!xeroInvoiceId) {
      throw new Error('Xero did not return invoice ID')
    }

    // Update invoice with Xero reference
    await supabase
      .from('invoices')
      .update({
        xero_invoice_id: xeroInvoiceId,
        xero_sync_status: 'synced',
        xero_sync_error: null,
        xero_synced_at: new Date().toISOString(),
      } as any)
      .eq('id', invoiceId)

    console.log(`Invoice ${invoiceId} synced to Xero: ${xeroInvoiceId}`)
    return { success: true, xeroInvoiceId }

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown Xero error'
    console.error('Xero sync failed:', error)

    // Update invoice with error
    await supabase
      .from('invoices')
      .update({
        xero_sync_status: 'failed',
        xero_sync_error: errorMessage,
      } as any)
      .eq('id', invoiceId)

    return { success: false, error: errorMessage }
  }
}

/**
 * Get existing Xero contact or create new one
 */
async function getOrCreateXeroContact(
  xero: any,
  tenantId: string,
  supabase: any,
  organizationId: string,
  participant: {
    id: string
    first_name: string
    last_name: string
    email: string | null
    ndis_number: string | null
  }
): Promise<string> {
  // Check cached mapping
  const { data: org } = await supabase
    .from('organizations')
    .select('xero_contact_mapping')
    .eq('id', organizationId)
    .single()

  const mapping = (org?.xero_contact_mapping || {}) as Record<string, string>

  if (mapping[participant.id]) {
    return mapping[participant.id]
  }

  // Search for existing contact by NDIS number or name
  const searchName = `${participant.first_name} ${participant.last_name}`
  let contactId: string | undefined

  try {
    const contacts = await xero.accountingApi.getContacts(
      tenantId,
      undefined,
      `Name=="${searchName}"`
    )

    if (contacts.body.contacts && contacts.body.contacts.length > 0) {
      contactId = contacts.body.contacts[0].contactID
    }
  } catch (e) {
    // Contact not found, will create
  }

  // Create new contact if not found
  if (!contactId) {
    const newContact: Contact = {
      name: searchName,
      firstName: participant.first_name,
      lastName: participant.last_name,
      emailAddress: participant.email || undefined,
      accountNumber: participant.ndis_number || undefined,
    }

    const result = await xero.accountingApi.createContacts(
      tenantId,
      { contacts: [newContact] }
    )

    contactId = result.body.contacts?.[0]?.contactID

    if (!contactId) {
      throw new Error('Failed to create Xero contact')
    }
  }

  // Cache mapping
  mapping[participant.id] = contactId
  await supabase
    .from('organizations')
    .update({ xero_contact_mapping: mapping } as any)
    .eq('id', organizationId)

  return contactId
}

/**
 * Retry failed Xero syncs for an organization
 */
export async function retryFailedXeroSyncs(organizationId: string): Promise<{
  retried: number
  succeeded: number
  failed: number
}> {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )

  const { data: failedInvoices } = await supabase
    .from('invoices')
    .select('id')
    .eq('organization_id', organizationId)
    .eq('xero_sync_status', 'failed')

  const results = { retried: 0, succeeded: 0, failed: 0 }

  for (const invoice of failedInvoices || []) {
    results.retried++
    const result = await syncInvoiceToXero(invoice.id)
    if (result.success) {
      results.succeeded++
    } else {
      results.failed++
    }
  }

  return results
}
```

Key features:
- Auto-creates Xero contacts for new participants
- Maps invoice line items to Xero format
- Caches contact mappings to avoid duplicate creates
- Records sync status and errors
- Provides retry function for failed syncs
  </action>
  <verify>
Run `pnpm typecheck` from apps/admin.
  </verify>
  <done>
Invoice sync function creates Xero invoices with proper contact and line item mapping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update invoice finalize to trigger Xero sync</name>
  <files>apps/admin/app/api/invoices/[id]/finalize/route.ts</files>
  <action>
Update or create the finalize endpoint to trigger Xero sync:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createClient as createServiceClient } from '@supabase/supabase-js'
import { syncInvoiceToXero } from '@/lib/xero/sync-invoice'

/**
 * Finalize an invoice
 * POST /api/invoices/[id]/finalize
 */
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const supabase = await createClient()
    const invoiceId = params.id

    // Verify authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get user's profile
    const { data: profile } = await supabase
      .from('profiles')
      .select('organization_id, role')
      .eq('id', user.id)
      .single()

    if (!profile?.organization_id) {
      return NextResponse.json({ error: 'No organization' }, { status: 400 })
    }

    // Only admin can finalize
    if (profile.role !== 'admin') {
      return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
    }

    // Fetch invoice
    const { data: invoice, error: invoiceError } = await supabase
      .from('invoices')
      .select('*')
      .eq('id', invoiceId)
      .eq('organization_id', profile.organization_id)
      .single()

    if (invoiceError || !invoice) {
      return NextResponse.json({ error: 'Invoice not found' }, { status: 404 })
    }

    if (invoice.status === 'finalized') {
      return NextResponse.json({ error: 'Invoice already finalized' }, { status: 400 })
    }

    // Use service client for update
    const serviceClient = createServiceClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Update invoice status to finalized
    const { error: updateError } = await serviceClient
      .from('invoices')
      .update({
        status: 'finalized',
        finalized_at: new Date().toISOString(),
        finalized_by: user.id,
      } as any)
      .eq('id', invoiceId)

    if (updateError) {
      return NextResponse.json({ error: 'Failed to finalize invoice' }, { status: 500 })
    }

    // Trigger Xero sync (async, don't block response)
    // Sync failure should not fail the finalize operation
    let xeroResult: { success: boolean; xeroInvoiceId?: string; error?: string } = {
      success: false,
      error: 'Not attempted'
    }

    try {
      xeroResult = await syncInvoiceToXero(invoiceId)
      console.log('Xero sync result:', xeroResult)
    } catch (xeroError) {
      console.error('Xero sync error (non-blocking):', xeroError)
      xeroResult = {
        success: false,
        error: xeroError instanceof Error ? xeroError.message : 'Sync failed'
      }
    }

    return NextResponse.json({
      success: true,
      invoiceId,
      xeroSync: xeroResult,
      message: 'Invoice finalized successfully',
    })

  } catch (error) {
    console.error('Finalize invoice error:', error)
    return NextResponse.json(
      { error: 'Failed to finalize invoice' },
      { status: 500 }
    )
  }
}
```

Key features:
- Validates admin role
- Updates invoice status to finalized
- Triggers Xero sync (non-blocking)
- Returns sync result in response
- Sync failure does not prevent finalization
  </action>
  <verify>
Run `pnpm typecheck`. Endpoint compiles.
  </verify>
  <done>
Finalize endpoint triggers Xero sync automatically when invoice is finalized.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update TypeScript types for new columns</name>
  <files>packages/types/src/database.ts</files>
  <action>
Add the new Xero-related columns to the Invoice type:

In the invoices table Row type, add:
- xero_invoice_id: string | null
- xero_sync_status: 'pending' | 'synced' | 'failed' | 'not_applicable' | null
- xero_sync_error: string | null
- xero_synced_at: string | null

In the organizations table Row type, add:
- xero_contact_mapping: Json | null

Follow existing patterns in database.ts for Insert and Update types.
  </action>
  <verify>
Run `pnpm typecheck` from monorepo root.
  </verify>
  <done>
TypeScript types updated for Xero sync tracking columns.
  </done>
</task>

</tasks>

<verification>
1. Finalize invoice when Xero is not connected - status becomes finalized, xero_sync_status = 'not_applicable'
2. Finalize invoice when Xero is connected - status becomes finalized, xero_sync_status = 'synced'
3. Xero invoice created with correct amounts and participant as contact
4. xero_invoice_id populated for reconciliation
5. If Xero sync fails, invoice still finalized, xero_sync_status = 'failed'
</verification>

<success_criteria>
- Invoice finalization triggers Xero sync automatically
- Participant mapped to Xero contact (created if needed)
- Invoice line items correctly mapped with GST-free tax type
- Xero invoice ID stored for reconciliation
- Sync failure logged but does not block finalization
</success_criteria>

<output>
After completion, create `.planning/phases/13-scale-features/13-07-SUMMARY.md`
</output>
