---
phase: 13-scale-features
plan: 10
type: execute
wave: 4
depends_on: ["13-01"]
files_modified:
  - apps/worker-mobile/lib/photo-sync.ts
  - apps/worker-mobile/components/ShiftPhotoCapture.tsx
  - apps/worker-mobile/stores/syncStore.ts
  - apps/admin/app/api/photos/upload/route.ts
  - supabase/migrations/20260127000006_shift_photos.sql
autonomous: true

must_haves:
  truths:
    - "Worker can capture up to 3 photos per shift"
    - "Photos are stored locally until network is available"
    - "Photos sync to Supabase Storage when online"
    - "Local photos are deleted after successful upload"
    - "Photos display on shift detail in admin dashboard"
  artifacts:
    - path: "apps/worker-mobile/lib/photo-sync.ts"
      provides: "Photo capture and sync functions"
      exports: ["captureShiftPhoto", "getShiftPhotos", "syncPendingPhotos"]
    - path: "apps/worker-mobile/components/ShiftPhotoCapture.tsx"
      provides: "Photo capture UI component"
      min_lines: 60
    - path: "apps/admin/app/api/photos/upload/route.ts"
      provides: "Photo upload API endpoint"
      exports: ["POST"]
  key_links:
    - from: "apps/worker-mobile/lib/photo-sync.ts"
      to: "syncStore"
      via: "addPendingAction"
      pattern: "addPendingAction"
---

<objective>
Implement offline photo capture with sync queue for shift evidence.

Purpose: Allow workers to capture photos during shifts (e.g., completed tasks, safety hazards) that sync when connectivity is restored, ensuring documentation even in poor network areas.

Output: Photo capture helpers, sync queue integration, upload API, storage schema.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-scale-features/13-RESEARCH.md

# Existing sync patterns
@apps/worker-mobile/stores/syncStore.ts
@apps/worker-mobile/lib/sync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shift photos migration</name>
  <files>supabase/migrations/20260127000006_shift_photos.sql</files>
  <action>
Create migration for shift photo storage:

```sql
-- Shift Photos Schema
-- For storing evidence photos taken during shifts

CREATE TABLE IF NOT EXISTS shift_photos (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  shift_id uuid REFERENCES shifts(id) ON DELETE CASCADE NOT NULL,
  worker_id uuid REFERENCES workers(id) NOT NULL,
  organization_id uuid REFERENCES organizations(id) NOT NULL,
  storage_path text NOT NULL,
  storage_url text,
  caption text,
  taken_at timestamptz NOT NULL,
  uploaded_at timestamptz DEFAULT now(),
  file_size_bytes integer,
  mime_type text DEFAULT 'image/jpeg',
  latitude numeric(10, 8),
  longitude numeric(11, 8)
);

-- RLS policies
ALTER TABLE shift_photos ENABLE ROW LEVEL SECURITY;

-- Org members can view shift photos
CREATE POLICY "org_members_view_shift_photos"
  ON shift_photos FOR SELECT
  TO authenticated
  USING (organization_id = get_user_organization_id() OR is_platform_admin());

-- Workers can insert their own photos
CREATE POLICY "workers_insert_shift_photos"
  ON shift_photos FOR INSERT
  TO authenticated
  WITH CHECK (
    organization_id = get_user_organization_id()
    AND worker_id IN (SELECT id FROM workers WHERE profile_id = auth.uid())
  );

-- Workers can delete their own photos (before shift finalized)
CREATE POLICY "workers_delete_own_photos"
  ON shift_photos FOR DELETE
  TO authenticated
  USING (
    worker_id IN (SELECT id FROM workers WHERE profile_id = auth.uid())
    AND EXISTS (
      SELECT 1 FROM shifts
      WHERE shifts.id = shift_photos.shift_id
      AND shifts.status NOT IN ('completed', 'invoiced')
    )
  );

-- Indexes
CREATE INDEX IF NOT EXISTS idx_shift_photos_shift ON shift_photos(shift_id);
CREATE INDEX IF NOT EXISTS idx_shift_photos_worker ON shift_photos(worker_id);

-- Storage bucket policy (run in Supabase dashboard or via SQL)
-- Create bucket: shift-photos
-- Policy: Authenticated users can upload to their org folder

COMMENT ON TABLE shift_photos IS 'Photos captured during shifts for documentation';
COMMENT ON COLUMN shift_photos.storage_path IS 'Path in Supabase Storage bucket';
```

Key design:
- Links to shift and worker
- Stores location data for verification
- Allows deletion only before shift completion
  </action>
  <verify>
Migration syntax is valid SQL.
  </verify>
  <done>
Shift photos table created with proper RLS.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create photo sync library</name>
  <files>apps/worker-mobile/lib/photo-sync.ts</files>
  <action>
Create photo capture and sync functions:

```typescript
import * as FileSystem from 'expo-file-system'
import * as ImagePicker from 'expo-image-picker'
import { useSyncStore } from '../stores/syncStore'

const PHOTO_DIR = FileSystem.documentDirectory + 'shift_photos/'
const MAX_PHOTOS_PER_SHIFT = 3

export interface CapturedPhoto {
  id: string
  localUri: string
  shiftId: string
  timestamp: string
  uploaded: boolean
  caption?: string
  latitude?: number
  longitude?: number
}

/**
 * Ensure photo directory exists
 */
export async function ensurePhotoDir(): Promise<void> {
  const dirInfo = await FileSystem.getInfoAsync(PHOTO_DIR)
  if (!dirInfo.exists) {
    await FileSystem.makeDirectoryAsync(PHOTO_DIR, { intermediates: true })
  }
}

/**
 * Get photos captured for a shift
 */
export async function getShiftPhotos(shiftId: string): Promise<CapturedPhoto[]> {
  await ensurePhotoDir()

  const files = await FileSystem.readDirectoryAsync(PHOTO_DIR)
  const shiftFiles = files.filter((f) => f.startsWith(shiftId))

  return shiftFiles.map((filename) => {
    const [, timestamp] = filename.replace('.jpg', '').split('_')
    return {
      id: filename.replace('.jpg', ''),
      localUri: PHOTO_DIR + filename,
      shiftId,
      timestamp: new Date(parseInt(timestamp)).toISOString(),
      uploaded: false,
    }
  })
}

/**
 * Count photos for a shift
 */
export async function countShiftPhotos(shiftId: string): Promise<number> {
  const photos = await getShiftPhotos(shiftId)
  return photos.length
}

/**
 * Capture a new photo for a shift
 * Returns null if cancelled or max photos reached
 */
export async function captureShiftPhoto(
  shiftId: string,
  location?: { latitude: number; longitude: number }
): Promise<CapturedPhoto | null> {
  // Check photo limit
  const count = await countShiftPhotos(shiftId)
  if (count >= MAX_PHOTOS_PER_SHIFT) {
    throw new Error(`Maximum ${MAX_PHOTOS_PER_SHIFT} photos per shift`)
  }

  // Request camera permission
  const { status } = await ImagePicker.requestCameraPermissionsAsync()
  if (status !== 'granted') {
    throw new Error('Camera permission required')
  }

  // Launch camera
  const result = await ImagePicker.launchCameraAsync({
    quality: 0.7, // Compress for storage
    allowsEditing: false,
    base64: false,
    exif: true,
  })

  if (result.canceled) {
    return null
  }

  await ensurePhotoDir()

  const asset = result.assets[0]
  const timestamp = Date.now()
  const photoId = `${shiftId}_${timestamp}`
  const localUri = `${PHOTO_DIR}${photoId}.jpg`

  // Move to permanent location
  await FileSystem.moveAsync({
    from: asset.uri,
    to: localUri,
  })

  const photo: CapturedPhoto = {
    id: photoId,
    localUri,
    shiftId,
    timestamp: new Date(timestamp).toISOString(),
    uploaded: false,
    latitude: location?.latitude,
    longitude: location?.longitude,
  }

  // Queue for sync
  useSyncStore.getState().addPendingAction({
    type: 'photo_upload',
    shiftId,
    timestamp: photo.timestamp,
    latitude: location?.latitude || 0,
    longitude: location?.longitude || 0,
    payload: {
      photoId,
      localUri,
    },
  })

  return photo
}

/**
 * Upload a single photo to server
 */
export async function uploadPhoto(
  photo: CapturedPhoto,
  organizationId: string,
  workerId: string,
  apiUrl: string
): Promise<{ success: boolean; storageUrl?: string; error?: string }> {
  try {
    // Read file as base64
    const base64 = await FileSystem.readAsStringAsync(photo.localUri, {
      encoding: FileSystem.EncodingType.Base64,
    })

    // Get file info for size
    const fileInfo = await FileSystem.getInfoAsync(photo.localUri)

    // Upload to API
    const response = await fetch(`${apiUrl}/api/photos/upload`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        photoId: photo.id,
        shiftId: photo.shiftId,
        workerId,
        organizationId,
        base64,
        timestamp: photo.timestamp,
        caption: photo.caption,
        latitude: photo.latitude,
        longitude: photo.longitude,
        fileSize: fileInfo.exists ? (fileInfo as any).size : 0,
      }),
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.message || 'Upload failed')
    }

    const { storageUrl } = await response.json()

    // Delete local file after successful upload
    await FileSystem.deleteAsync(photo.localUri, { idempotent: true })

    return { success: true, storageUrl }
  } catch (error) {
    console.error('Photo upload failed:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Upload failed',
    }
  }
}

/**
 * Sync all pending photos for a shift
 */
export async function syncShiftPhotos(
  shiftId: string,
  organizationId: string,
  workerId: string,
  apiUrl: string
): Promise<{ synced: number; failed: number }> {
  const photos = await getShiftPhotos(shiftId)
  let synced = 0
  let failed = 0

  for (const photo of photos) {
    const result = await uploadPhoto(photo, organizationId, workerId, apiUrl)
    if (result.success) {
      synced++
    } else {
      failed++
    }
  }

  return { synced, failed }
}

/**
 * Delete a local photo
 */
export async function deleteLocalPhoto(photoId: string): Promise<void> {
  const localUri = `${PHOTO_DIR}${photoId}.jpg`
  await FileSystem.deleteAsync(localUri, { idempotent: true })
}

/**
 * Get total size of pending photos
 */
export async function getPendingPhotoSize(): Promise<number> {
  await ensurePhotoDir()

  const files = await FileSystem.readDirectoryAsync(PHOTO_DIR)
  let totalSize = 0

  for (const file of files) {
    const info = await FileSystem.getInfoAsync(PHOTO_DIR + file)
    if (info.exists && 'size' in info) {
      totalSize += (info as any).size
    }
  }

  return totalSize
}

/**
 * Clear all pending photos (for logout)
 */
export async function clearAllPendingPhotos(): Promise<void> {
  await ensurePhotoDir()

  const files = await FileSystem.readDirectoryAsync(PHOTO_DIR)
  for (const file of files) {
    await FileSystem.deleteAsync(PHOTO_DIR + file, { idempotent: true })
  }
}
```

Key features:
- 3 photo limit per shift (per CONTEXT.md)
- Local storage in document directory
- Compression on capture (0.7 quality)
- Location metadata for verification
- Auto-delete after successful upload
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
Photo sync library handles capture, storage, and upload.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create photo capture component</name>
  <files>apps/worker-mobile/components/ShiftPhotoCapture.tsx</files>
  <action>
Create UI component for capturing and viewing shift photos:

```typescript
import { useState, useEffect } from 'react'
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  StyleSheet,
  Alert,
  ScrollView,
  ActivityIndicator,
} from 'react-native'
import { Ionicons } from '@expo/vector-icons'
import * as Location from 'expo-location'

import {
  captureShiftPhoto,
  getShiftPhotos,
  deleteLocalPhoto,
  type CapturedPhoto,
} from '../lib/photo-sync'

interface ShiftPhotoCaptureProps {
  shiftId: string
  maxPhotos?: number
  disabled?: boolean
  onPhotoAdded?: (photo: CapturedPhoto) => void
}

export function ShiftPhotoCapture({
  shiftId,
  maxPhotos = 3,
  disabled = false,
  onPhotoAdded,
}: ShiftPhotoCaptureProps) {
  const [photos, setPhotos] = useState<CapturedPhoto[]>([])
  const [isCapturing, setIsCapturing] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    loadPhotos()
  }, [shiftId])

  const loadPhotos = async () => {
    setIsLoading(true)
    try {
      const shiftPhotos = await getShiftPhotos(shiftId)
      setPhotos(shiftPhotos)
    } catch (error) {
      console.error('Failed to load photos:', error)
    }
    setIsLoading(false)
  }

  const handleCapture = async () => {
    if (disabled || photos.length >= maxPhotos) return

    setIsCapturing(true)

    try {
      // Get current location
      let location: { latitude: number; longitude: number } | undefined

      const { status } = await Location.requestForegroundPermissionsAsync()
      if (status === 'granted') {
        const loc = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.Balanced,
        })
        location = {
          latitude: loc.coords.latitude,
          longitude: loc.coords.longitude,
        }
      }

      const photo = await captureShiftPhoto(shiftId, location)

      if (photo) {
        setPhotos((prev) => [...prev, photo])
        onPhotoAdded?.(photo)
      }
    } catch (error) {
      Alert.alert(
        'Error',
        error instanceof Error ? error.message : 'Failed to capture photo'
      )
    }

    setIsCapturing(false)
  }

  const handleDelete = (photoId: string) => {
    Alert.alert(
      'Delete Photo',
      'Are you sure you want to delete this photo?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteLocalPhoto(photoId)
              setPhotos((prev) => prev.filter((p) => p.id !== photoId))
            } catch (error) {
              Alert.alert('Error', 'Failed to delete photo')
            }
          },
        },
      ]
    )
  }

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="small" color="#66BB6A" />
      </View>
    )
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Shift Photos</Text>
        <Text style={styles.count}>
          {photos.length} / {maxPhotos}
        </Text>
      </View>

      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        <View style={styles.photosRow}>
          {/* Existing photos */}
          {photos.map((photo) => (
            <View key={photo.id} style={styles.photoContainer}>
              <Image source={{ uri: photo.localUri }} style={styles.photo} />
              {!disabled && (
                <TouchableOpacity
                  style={styles.deleteButton}
                  onPress={() => handleDelete(photo.id)}
                >
                  <Ionicons name="close-circle" size={24} color="#E53935" />
                </TouchableOpacity>
              )}
              {!photo.uploaded && (
                <View style={styles.pendingBadge}>
                  <Ionicons name="cloud-upload-outline" size={12} color="#fff" />
                </View>
              )}
            </View>
          ))}

          {/* Add photo button */}
          {photos.length < maxPhotos && !disabled && (
            <TouchableOpacity
              style={styles.addButton}
              onPress={handleCapture}
              disabled={isCapturing}
            >
              {isCapturing ? (
                <ActivityIndicator color="#66BB6A" />
              ) : (
                <>
                  <Ionicons name="camera" size={32} color="#66BB6A" />
                  <Text style={styles.addButtonText}>Add Photo</Text>
                </>
              )}
            </TouchableOpacity>
          )}
        </View>
      </ScrollView>

      {photos.length === 0 && (
        <Text style={styles.emptyText}>
          Tap Add Photo to document your shift
        </Text>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    marginVertical: 16,
  },
  loadingContainer: {
    padding: 24,
    alignItems: 'center',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
  },
  count: {
    fontSize: 14,
    color: '#666',
  },
  photosRow: {
    flexDirection: 'row',
    gap: 12,
  },
  photoContainer: {
    position: 'relative',
  },
  photo: {
    width: 100,
    height: 100,
    borderRadius: 8,
    backgroundColor: '#f0f0f0',
  },
  deleteButton: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#fff',
    borderRadius: 12,
  },
  pendingBadge: {
    position: 'absolute',
    bottom: 4,
    right: 4,
    backgroundColor: '#FF9800',
    borderRadius: 10,
    padding: 4,
  },
  addButton: {
    width: 100,
    height: 100,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#66BB6A',
    borderStyle: 'dashed',
    justifyContent: 'center',
    alignItems: 'center',
  },
  addButtonText: {
    color: '#66BB6A',
    fontSize: 12,
    marginTop: 4,
  },
  emptyText: {
    color: '#999',
    fontSize: 14,
    textAlign: 'center',
    marginTop: 8,
  },
})
```

Features:
- Horizontal scroll for photo thumbnails
- Camera capture with location
- Delete button on each photo
- "Pending upload" badge indicator
- Max photo limit enforcement
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
Photo capture component provides intuitive UI for shift documentation.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update sync store for photos</name>
  <files>apps/worker-mobile/stores/syncStore.ts</files>
  <action>
Extend sync store to handle photo upload actions:

Add to existing syncStore types:

```typescript
// Add photo_upload to PendingAction type union
type ActionType = 'check_in' | 'check_out' | 'note' | 'photo_upload'

// Ensure payload can handle photo data
interface PendingAction {
  id: string
  type: ActionType
  shiftId: string
  timestamp: string
  latitude: number
  longitude: number
  payload?: {
    // For check-in/out
    note?: string
    // For photos
    photoId?: string
    localUri?: string
  }
  retryCount: number
  createdAt: string
}

// Add photo-specific sync method
syncPendingPhotos: async () => {
  const { pendingActions, removePendingAction, updatePendingAction } = get()
  const photoActions = pendingActions.filter(a => a.type === 'photo_upload')

  for (const action of photoActions) {
    if (!action.payload?.photoId || !action.payload?.localUri) continue

    try {
      const result = await uploadPhoto(
        {
          id: action.payload.photoId,
          localUri: action.payload.localUri,
          shiftId: action.shiftId,
          timestamp: action.timestamp,
          uploaded: false,
        },
        // These would come from auth store
        organizationId,
        workerId,
        apiUrl
      )

      if (result.success) {
        removePendingAction(action.id)
      } else {
        // Increment retry count
        updatePendingAction(action.id, {
          retryCount: action.retryCount + 1,
        })
      }
    } catch (error) {
      console.error('Photo sync failed:', error)
    }
  }
}
```

This integrates photo uploads with the existing offline sync queue.
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
Sync store handles photo upload queue with retries.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create photo upload API endpoint</name>
  <files>apps/admin/app/api/photos/upload/route.ts</files>
  <action>
Create API endpoint for receiving photo uploads:

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

/**
 * Upload shift photo to Supabase Storage
 * POST /api/photos/upload
 */
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const {
      photoId,
      shiftId,
      workerId,
      organizationId,
      base64,
      timestamp,
      caption,
      latitude,
      longitude,
      fileSize,
    } = body

    if (!photoId || !shiftId || !workerId || !organizationId || !base64) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    // Create service client for storage operations
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Verify shift belongs to organization
    const { data: shift, error: shiftError } = await supabase
      .from('shifts')
      .select('id, organization_id')
      .eq('id', shiftId)
      .eq('organization_id', organizationId)
      .single()

    if (shiftError || !shift) {
      return NextResponse.json(
        { error: 'Shift not found or access denied' },
        { status: 404 }
      )
    }

    // Convert base64 to buffer
    const buffer = Buffer.from(base64, 'base64')

    // Generate storage path: org_id/shift_id/photo_id.jpg
    const storagePath = `${organizationId}/${shiftId}/${photoId}.jpg`

    // Upload to Supabase Storage
    const { error: uploadError } = await supabase.storage
      .from('shift-photos')
      .upload(storagePath, buffer, {
        contentType: 'image/jpeg',
        upsert: false,
      })

    if (uploadError) {
      console.error('Storage upload failed:', uploadError)
      return NextResponse.json(
        { error: 'Failed to upload photo' },
        { status: 500 }
      )
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from('shift-photos')
      .getPublicUrl(storagePath)

    // Insert record in shift_photos table
    const { error: insertError } = await supabase.from('shift_photos').insert({
      id: photoId,
      shift_id: shiftId,
      worker_id: workerId,
      organization_id: organizationId,
      storage_path: storagePath,
      storage_url: urlData.publicUrl,
      caption: caption || null,
      taken_at: timestamp,
      file_size_bytes: fileSize || buffer.length,
      latitude: latitude || null,
      longitude: longitude || null,
    } as any)

    if (insertError) {
      // Cleanup uploaded file
      await supabase.storage.from('shift-photos').remove([storagePath])

      console.error('Database insert failed:', insertError)
      return NextResponse.json(
        { error: 'Failed to save photo record' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      photoId,
      storageUrl: urlData.publicUrl,
    })
  } catch (error) {
    console.error('Photo upload error:', error)
    return NextResponse.json(
      { error: 'Photo upload failed' },
      { status: 500 }
    )
  }
}

/**
 * Delete a shift photo
 * DELETE /api/photos/upload?photoId=xxx
 */
export async function DELETE(request: Request) {
  try {
    const url = new URL(request.url)
    const photoId = url.searchParams.get('photoId')

    if (!photoId) {
      return NextResponse.json(
        { error: 'Photo ID required' },
        { status: 400 }
      )
    }

    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Get photo record
    const { data: photo, error: fetchError } = await supabase
      .from('shift_photos')
      .select('storage_path')
      .eq('id', photoId)
      .single()

    if (fetchError || !photo) {
      return NextResponse.json(
        { error: 'Photo not found' },
        { status: 404 }
      )
    }

    // Delete from storage
    await supabase.storage.from('shift-photos').remove([photo.storage_path])

    // Delete record
    await supabase.from('shift_photos').delete().eq('id', photoId)

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Photo delete error:', error)
    return NextResponse.json(
      { error: 'Failed to delete photo' },
      { status: 500 }
    )
  }
}
```

Features:
- Validates shift ownership
- Uploads to Supabase Storage
- Creates database record with metadata
- Rollback on failure
- Delete endpoint for cleanup
  </action>
  <verify>
Run `pnpm typecheck` from apps/admin.
  </verify>
  <done>
Photo upload API handles receiving and storing shift photos.
  </done>
</task>

</tasks>

<verification>
1. Capture photo on mobile - saves to local storage
2. Photo appears in shift photo component with pending badge
3. When online, photo syncs to Supabase Storage
4. After sync, local file deleted
5. Photo appears on shift detail in admin dashboard
6. Cannot add more than 3 photos per shift
</verification>

<success_criteria>
- Photos captured and stored locally when offline
- 3 photo per shift limit enforced
- Photos sync automatically when online
- Local photos deleted after successful upload
- Photos visible in admin dashboard on shift detail
</success_criteria>

<output>
After completion, create `.planning/phases/13-scale-features/13-10-SUMMARY.md`
</output>
