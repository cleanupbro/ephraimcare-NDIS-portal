---
phase: 13-scale-features
plan: 09
type: execute
wave: 4
depends_on: ["13-01"]
files_modified:
  - apps/worker-mobile/lib/biometrics.ts
  - apps/worker-mobile/lib/pin-auth.ts
  - apps/worker-mobile/components/BiometricPrompt.tsx
  - apps/worker-mobile/components/PinSetup.tsx
  - apps/worker-mobile/components/PinEntry.tsx
  - apps/worker-mobile/stores/authStore.ts
autonomous: true

must_haves:
  truths:
    - "Worker can authenticate with fingerprint or face recognition"
    - "If biometrics unavailable or fail, PIN entry is fallback"
    - "PIN is 4-6 digits, set during worker onboarding"
    - "PIN is stored securely using expo-secure-store"
    - "Biometric/PIN required before check-in/check-out"
  artifacts:
    - path: "apps/worker-mobile/lib/biometrics.ts"
      provides: "Biometric authentication helpers"
      exports: ["checkBiometricSupport", "authenticateWithBiometrics"]
    - path: "apps/worker-mobile/lib/pin-auth.ts"
      provides: "PIN storage and verification"
      exports: ["setPin", "verifyPin", "hasPin"]
    - path: "apps/worker-mobile/components/BiometricPrompt.tsx"
      provides: "Biometric authentication UI"
      min_lines: 40
  key_links:
    - from: "apps/worker-mobile/components/BiometricPrompt.tsx"
      to: "authenticateWithBiometrics"
      via: "function call"
      pattern: "authenticateWithBiometrics"
---

<objective>
Implement biometric authentication with PIN fallback for the worker mobile app.

Purpose: Provide secure, convenient authentication for workers when checking in/out of shifts, reducing friction while maintaining security.

Output: Biometric auth helpers, PIN setup/entry components, integration with check-in flow.
</objective>

<execution_context>
@/Users/shamalkrishna/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shamalkrishna/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-scale-features/13-RESEARCH.md

# Existing mobile patterns
@apps/worker-mobile/stores/authStore.ts
@apps/worker-mobile/app/(app)/shifts/[id].tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create biometrics helper</name>
  <files>apps/worker-mobile/lib/biometrics.ts</files>
  <action>
Create biometric authentication helpers using expo-local-authentication:

```typescript
import * as LocalAuthentication from 'expo-local-authentication'

export type BiometricType = 'fingerprint' | 'facial' | 'iris' | 'none'

export interface BiometricStatus {
  supported: boolean
  enrolled: boolean
  type: BiometricType
}

/**
 * Check if device supports biometric authentication
 */
export async function checkBiometricSupport(): Promise<BiometricStatus> {
  const hasHardware = await LocalAuthentication.hasHardwareAsync()
  const isEnrolled = await LocalAuthentication.isEnrolledAsync()
  const supportedTypes = await LocalAuthentication.supportedAuthenticationTypesAsync()

  let type: BiometricType = 'none'
  if (supportedTypes.includes(LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION)) {
    type = 'facial'
  } else if (supportedTypes.includes(LocalAuthentication.AuthenticationType.FINGERPRINT)) {
    type = 'fingerprint'
  } else if (supportedTypes.includes(LocalAuthentication.AuthenticationType.IRIS)) {
    type = 'iris'
  }

  return {
    supported: hasHardware,
    enrolled: isEnrolled,
    type,
  }
}

export interface AuthResult {
  success: boolean
  error?: string
  errorType?: 'user_cancel' | 'system_cancel' | 'not_enrolled' | 'fallback' | 'unknown'
}

/**
 * Authenticate user with biometrics
 * Returns success/failure with error details
 */
export async function authenticateWithBiometrics(
  promptMessage: string = 'Authenticate to continue'
): Promise<AuthResult> {
  try {
    const result = await LocalAuthentication.authenticateAsync({
      promptMessage,
      fallbackLabel: 'Use PIN',
      disableDeviceFallback: true, // We handle our own PIN fallback
      cancelLabel: 'Cancel',
    })

    if (result.success) {
      return { success: true }
    }

    // Map error types
    let errorType: AuthResult['errorType'] = 'unknown'
    if (result.error === 'user_cancel') {
      errorType = 'user_cancel'
    } else if (result.error === 'system_cancel') {
      errorType = 'system_cancel'
    } else if (result.error === 'not_enrolled') {
      errorType = 'not_enrolled'
    } else if (result.error === 'user_fallback') {
      errorType = 'fallback'
    }

    return {
      success: false,
      error: result.error || 'Authentication failed',
      errorType,
    }
  } catch (error) {
    console.error('Biometric auth error:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Biometric authentication failed',
      errorType: 'unknown',
    }
  }
}

/**
 * Get human-readable biometric type label
 */
export function getBiometricLabel(type: BiometricType): string {
  switch (type) {
    case 'facial':
      return 'Face ID'
    case 'fingerprint':
      return 'Fingerprint'
    case 'iris':
      return 'Iris'
    default:
      return 'Biometric'
  }
}
```

Key features:
- Detects available biometric types
- Handles authentication with custom prompts
- Maps error types for better UX
- Disables system fallback (we use custom PIN)
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
Biometric helpers provide clean API for fingerprint/face authentication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PIN authentication helpers</name>
  <files>apps/worker-mobile/lib/pin-auth.ts</files>
  <action>
Create PIN storage and verification using expo-secure-store:

```typescript
import * as SecureStore from 'expo-secure-store'
import * as Crypto from 'expo-crypto'

const PIN_KEY = 'worker_pin_hash'
const PIN_SALT = 'ephraim_care_pin_salt_v1'

/**
 * Hash PIN using SHA-256
 * Uses a salt to prevent rainbow table attacks
 */
async function hashPin(pin: string): Promise<string> {
  const saltedPin = pin + PIN_SALT
  const hash = await Crypto.digestStringAsync(
    Crypto.CryptoDigestAlgorithm.SHA256,
    saltedPin
  )
  return hash
}

/**
 * Check if worker has set up a PIN
 */
export async function hasPin(): Promise<boolean> {
  const stored = await SecureStore.getItemAsync(PIN_KEY)
  return stored !== null
}

/**
 * Set worker's PIN
 * PIN must be 4-6 digits
 */
export async function setPin(pin: string): Promise<{ success: boolean; error?: string }> {
  // Validate PIN format
  if (!/^\d{4,6}$/.test(pin)) {
    return { success: false, error: 'PIN must be 4-6 digits' }
  }

  try {
    const hashedPin = await hashPin(pin)
    await SecureStore.setItemAsync(PIN_KEY, hashedPin, {
      keychainAccessible: SecureStore.WHEN_UNLOCKED,
    })
    return { success: true }
  } catch (error) {
    console.error('Failed to save PIN:', error)
    return { success: false, error: 'Failed to save PIN' }
  }
}

/**
 * Verify entered PIN against stored PIN
 */
export async function verifyPin(pin: string): Promise<boolean> {
  try {
    const storedHash = await SecureStore.getItemAsync(PIN_KEY)
    if (!storedHash) return false

    const inputHash = await hashPin(pin)
    return storedHash === inputHash
  } catch (error) {
    console.error('PIN verification error:', error)
    return false
  }
}

/**
 * Clear stored PIN (for logout/reset)
 */
export async function clearPin(): Promise<void> {
  try {
    await SecureStore.deleteItemAsync(PIN_KEY)
  } catch (error) {
    console.error('Failed to clear PIN:', error)
  }
}

/**
 * Update PIN (requires current PIN verification)
 */
export async function updatePin(
  currentPin: string,
  newPin: string
): Promise<{ success: boolean; error?: string }> {
  const isValid = await verifyPin(currentPin)
  if (!isValid) {
    return { success: false, error: 'Current PIN is incorrect' }
  }

  return setPin(newPin)
}
```

Key features:
- SHA-256 hashing with salt for security
- 4-6 digit validation
- Secure storage with keychain protection
- Update PIN with current PIN verification
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
PIN helpers provide secure storage and verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PIN setup component</name>
  <files>apps/worker-mobile/components/PinSetup.tsx</files>
  <action>
Create PIN setup screen for worker onboarding:

```typescript
import { useState, useRef } from 'react'
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
} from 'react-native'
import { setPin } from '../lib/pin-auth'

interface PinSetupProps {
  onComplete: () => void
  onSkip?: () => void
}

export function PinSetup({ onComplete, onSkip }: PinSetupProps) {
  const [step, setStep] = useState<'enter' | 'confirm'>('enter')
  const [pin, setPin] = useState('')
  const [confirmPin, setConfirmPin] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  const confirmInputRef = useRef<TextInput>(null)

  const handlePinChange = (value: string) => {
    // Only allow digits
    const cleaned = value.replace(/\D/g, '').slice(0, 6)

    if (step === 'enter') {
      setPin(cleaned)
      setError(null)

      // Auto-advance when PIN is 4-6 digits and user stops typing
      if (cleaned.length >= 4) {
        // Small delay to allow user to enter more digits
        setTimeout(() => {
          if (cleaned.length >= 4 && cleaned.length <= 6) {
            setStep('confirm')
            confirmInputRef.current?.focus()
          }
        }, 500)
      }
    } else {
      setConfirmPin(cleaned)
      setError(null)
    }
  }

  const handleConfirm = async () => {
    if (confirmPin !== pin) {
      setError('PINs do not match')
      setConfirmPin('')
      return
    }

    setIsLoading(true)
    const result = await setPin(pin)
    setIsLoading(false)

    if (result.success) {
      onComplete()
    } else {
      setError(result.error || 'Failed to save PIN')
    }
  }

  const handleBack = () => {
    setStep('enter')
    setConfirmPin('')
    setError(null)
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>
        {step === 'enter' ? 'Create Your PIN' : 'Confirm Your PIN'}
      </Text>
      <Text style={styles.subtitle}>
        {step === 'enter'
          ? 'Enter a 4-6 digit PIN for quick authentication'
          : 'Re-enter your PIN to confirm'}
      </Text>

      <View style={styles.pinContainer}>
        {step === 'enter' ? (
          <TextInput
            style={styles.pinInput}
            value={pin}
            onChangeText={handlePinChange}
            keyboardType="number-pad"
            secureTextEntry
            maxLength={6}
            autoFocus
            placeholder="Enter PIN"
            placeholderTextColor="#999"
          />
        ) : (
          <TextInput
            ref={confirmInputRef}
            style={styles.pinInput}
            value={confirmPin}
            onChangeText={handlePinChange}
            keyboardType="number-pad"
            secureTextEntry
            maxLength={6}
            autoFocus
            placeholder="Confirm PIN"
            placeholderTextColor="#999"
          />
        )}

        {/* PIN dots indicator */}
        <View style={styles.dotsContainer}>
          {[0, 1, 2, 3, 4, 5].map((i) => (
            <View
              key={i}
              style={[
                styles.dot,
                i < (step === 'enter' ? pin.length : confirmPin.length)
                  ? styles.dotFilled
                  : styles.dotEmpty,
              ]}
            />
          ))}
        </View>
      </View>

      {error && <Text style={styles.error}>{error}</Text>}

      <View style={styles.buttonContainer}>
        {step === 'confirm' && (
          <TouchableOpacity style={styles.backButton} onPress={handleBack}>
            <Text style={styles.backButtonText}>Back</Text>
          </TouchableOpacity>
        )}

        {step === 'enter' && pin.length >= 4 && (
          <TouchableOpacity
            style={styles.continueButton}
            onPress={() => {
              setStep('confirm')
              confirmInputRef.current?.focus()
            }}
          >
            <Text style={styles.continueButtonText}>Continue</Text>
          </TouchableOpacity>
        )}

        {step === 'confirm' && confirmPin.length >= 4 && (
          <TouchableOpacity
            style={[styles.continueButton, isLoading && styles.buttonDisabled]}
            onPress={handleConfirm}
            disabled={isLoading}
          >
            <Text style={styles.continueButtonText}>
              {isLoading ? 'Saving...' : 'Save PIN'}
            </Text>
          </TouchableOpacity>
        )}
      </View>

      {onSkip && step === 'enter' && (
        <TouchableOpacity style={styles.skipButton} onPress={onSkip}>
          <Text style={styles.skipButtonText}>Skip for now</Text>
        </TouchableOpacity>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    justifyContent: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 32,
  },
  pinContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  pinInput: {
    fontSize: 32,
    letterSpacing: 8,
    textAlign: 'center',
    width: '100%',
    paddingVertical: 16,
    borderWidth: 0,
    // Hide the actual input, we show dots instead
    position: 'absolute',
    opacity: 0,
  },
  dotsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 12,
  },
  dot: {
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#66BB6A',
  },
  dotEmpty: {
    backgroundColor: 'transparent',
  },
  dotFilled: {
    backgroundColor: '#66BB6A',
  },
  error: {
    color: '#E53935',
    textAlign: 'center',
    marginBottom: 16,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 12,
  },
  backButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#66BB6A',
  },
  backButtonText: {
    color: '#66BB6A',
    fontSize: 16,
    fontWeight: '600',
  },
  continueButton: {
    backgroundColor: '#66BB6A',
    paddingVertical: 12,
    paddingHorizontal: 32,
    borderRadius: 8,
  },
  continueButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  buttonDisabled: {
    opacity: 0.5,
  },
  skipButton: {
    marginTop: 24,
    alignItems: 'center',
  },
  skipButtonText: {
    color: '#999',
    fontSize: 14,
  },
})
```

Features:
- Two-step PIN entry with confirmation
- Visual dots indicator
- 4-6 digit validation
- Optional skip for onboarding flexibility
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
PIN setup component guides worker through secure PIN creation.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create PIN entry component</name>
  <files>apps/worker-mobile/components/PinEntry.tsx</files>
  <action>
Create PIN entry screen for authentication:

```typescript
import { useState, useEffect } from 'react'
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Vibration,
} from 'react-native'
import { verifyPin } from '../lib/pin-auth'

interface PinEntryProps {
  onSuccess: () => void
  onCancel?: () => void
  maxAttempts?: number
}

export function PinEntry({ onSuccess, onCancel, maxAttempts = 5 }: PinEntryProps) {
  const [pin, setPin] = useState('')
  const [error, setError] = useState<string | null>(null)
  const [attempts, setAttempts] = useState(0)
  const [isLocked, setIsLocked] = useState(false)
  const [lockCountdown, setLockCountdown] = useState(0)

  // Lockout timer
  useEffect(() => {
    if (lockCountdown > 0) {
      const timer = setTimeout(() => setLockCountdown(lockCountdown - 1), 1000)
      return () => clearTimeout(timer)
    } else if (isLocked && lockCountdown === 0) {
      setIsLocked(false)
      setAttempts(0)
    }
  }, [lockCountdown, isLocked])

  const handlePinChange = async (value: string) => {
    if (isLocked) return

    const cleaned = value.replace(/\D/g, '').slice(0, 6)
    setPin(cleaned)
    setError(null)

    // Auto-verify when 4+ digits
    if (cleaned.length >= 4) {
      const isValid = await verifyPin(cleaned)

      if (isValid) {
        onSuccess()
      } else {
        Vibration.vibrate(200)
        const newAttempts = attempts + 1
        setAttempts(newAttempts)
        setPin('')

        if (newAttempts >= maxAttempts) {
          setIsLocked(true)
          setLockCountdown(30) // 30 second lockout
          setError('Too many attempts. Try again in 30 seconds.')
        } else {
          setError(`Incorrect PIN. ${maxAttempts - newAttempts} attempts remaining.`)
        }
      }
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Enter Your PIN</Text>

      <View style={styles.pinContainer}>
        <TextInput
          style={styles.pinInput}
          value={pin}
          onChangeText={handlePinChange}
          keyboardType="number-pad"
          secureTextEntry
          maxLength={6}
          autoFocus
          editable={!isLocked}
        />

        {/* PIN dots indicator */}
        <View style={styles.dotsContainer}>
          {[0, 1, 2, 3, 4, 5].map((i) => (
            <View
              key={i}
              style={[
                styles.dot,
                i < pin.length ? styles.dotFilled : styles.dotEmpty,
                error ? styles.dotError : null,
              ]}
            />
          ))}
        </View>
      </View>

      {error && <Text style={styles.error}>{error}</Text>}

      {isLocked && (
        <Text style={styles.lockText}>
          Locked for {lockCountdown} seconds
        </Text>
      )}

      {onCancel && (
        <TouchableOpacity style={styles.cancelButton} onPress={onCancel}>
          <Text style={styles.cancelButtonText}>Cancel</Text>
        </TouchableOpacity>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    justifyContent: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 32,
  },
  pinContainer: {
    alignItems: 'center',
    marginBottom: 24,
  },
  pinInput: {
    position: 'absolute',
    opacity: 0,
    width: '100%',
    height: 50,
  },
  dotsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 12,
  },
  dot: {
    width: 16,
    height: 16,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#66BB6A',
  },
  dotEmpty: {
    backgroundColor: 'transparent',
  },
  dotFilled: {
    backgroundColor: '#66BB6A',
  },
  dotError: {
    borderColor: '#E53935',
    backgroundColor: '#E53935',
  },
  error: {
    color: '#E53935',
    textAlign: 'center',
    marginBottom: 16,
  },
  lockText: {
    color: '#FF9800',
    textAlign: 'center',
    fontSize: 16,
    marginBottom: 16,
  },
  cancelButton: {
    marginTop: 24,
    alignItems: 'center',
  },
  cancelButtonText: {
    color: '#666',
    fontSize: 16,
  },
})
```

Features:
- Auto-verify on 4+ digit entry
- Vibration feedback on wrong PIN
- Attempt limiting with 30s lockout
- Visual error state on dots
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
PIN entry component with security features like lockout.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create biometric prompt component</name>
  <files>apps/worker-mobile/components/BiometricPrompt.tsx</files>
  <action>
Create unified biometric/PIN authentication prompt:

```typescript
import { useState, useEffect } from 'react'
import { View, Text, TouchableOpacity, StyleSheet, ActivityIndicator } from 'react-native'
import { Ionicons } from '@expo/vector-icons'

import {
  checkBiometricSupport,
  authenticateWithBiometrics,
  getBiometricLabel,
  type BiometricStatus,
} from '../lib/biometrics'
import { hasPin } from '../lib/pin-auth'
import { PinEntry } from './PinEntry'

interface BiometricPromptProps {
  title?: string
  subtitle?: string
  onSuccess: () => void
  onCancel?: () => void
}

export function BiometricPrompt({
  title = 'Authenticate',
  subtitle = 'Verify your identity to continue',
  onSuccess,
  onCancel,
}: BiometricPromptProps) {
  const [biometricStatus, setBiometricStatus] = useState<BiometricStatus | null>(null)
  const [showPinFallback, setShowPinFallback] = useState(false)
  const [hasPinSet, setHasPinSet] = useState(false)
  const [isAuthenticating, setIsAuthenticating] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    loadAuthStatus()
  }, [])

  const loadAuthStatus = async () => {
    const [bioStatus, pinStatus] = await Promise.all([
      checkBiometricSupport(),
      hasPin(),
    ])
    setBiometricStatus(bioStatus)
    setHasPinSet(pinStatus)

    // If biometrics available and enrolled, auto-trigger
    if (bioStatus.supported && bioStatus.enrolled) {
      handleBiometricAuth()
    } else if (pinStatus) {
      // No biometrics, but has PIN - show PIN
      setShowPinFallback(true)
    }
  }

  const handleBiometricAuth = async () => {
    setIsAuthenticating(true)
    setError(null)

    const result = await authenticateWithBiometrics(title)

    setIsAuthenticating(false)

    if (result.success) {
      onSuccess()
    } else if (result.errorType === 'fallback' || result.errorType === 'user_cancel') {
      // User wants to use PIN
      if (hasPinSet) {
        setShowPinFallback(true)
      } else {
        setError('PIN not set up. Please contact your administrator.')
      }
    } else {
      setError(result.error || 'Authentication failed')
    }
  }

  // Show PIN entry
  if (showPinFallback) {
    return (
      <PinEntry
        onSuccess={onSuccess}
        onCancel={() => {
          if (biometricStatus?.supported && biometricStatus?.enrolled) {
            setShowPinFallback(false)
          } else {
            onCancel?.()
          }
        }}
      />
    )
  }

  // Loading state
  if (!biometricStatus) {
    return (
      <View style={styles.container}>
        <ActivityIndicator size="large" color="#66BB6A" />
      </View>
    )
  }

  const biometricIcon = biometricStatus.type === 'facial' ? 'scan' : 'finger-print'
  const biometricLabel = getBiometricLabel(biometricStatus.type)

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <Text style={styles.subtitle}>{subtitle}</Text>

      {biometricStatus.supported && biometricStatus.enrolled && (
        <TouchableOpacity
          style={styles.biometricButton}
          onPress={handleBiometricAuth}
          disabled={isAuthenticating}
        >
          {isAuthenticating ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <>
              <Ionicons name={biometricIcon as any} size={48} color="#fff" />
              <Text style={styles.biometricButtonText}>
                Use {biometricLabel}
              </Text>
            </>
          )}
        </TouchableOpacity>
      )}

      {error && <Text style={styles.error}>{error}</Text>}

      {hasPinSet && (
        <TouchableOpacity
          style={styles.pinButton}
          onPress={() => setShowPinFallback(true)}
        >
          <Ionicons name="keypad" size={20} color="#66BB6A" />
          <Text style={styles.pinButtonText}>Use PIN instead</Text>
        </TouchableOpacity>
      )}

      {onCancel && (
        <TouchableOpacity style={styles.cancelButton} onPress={onCancel}>
          <Text style={styles.cancelButtonText}>Cancel</Text>
        </TouchableOpacity>
      )}
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 24,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 32,
  },
  biometricButton: {
    backgroundColor: '#66BB6A',
    padding: 32,
    borderRadius: 16,
    alignItems: 'center',
    marginBottom: 24,
  },
  biometricButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
    marginTop: 8,
  },
  error: {
    color: '#E53935',
    textAlign: 'center',
    marginBottom: 16,
  },
  pinButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#66BB6A',
    gap: 8,
  },
  pinButtonText: {
    color: '#66BB6A',
    fontSize: 16,
    fontWeight: '600',
  },
  cancelButton: {
    marginTop: 24,
  },
  cancelButtonText: {
    color: '#666',
    fontSize: 16,
  },
})
```

Features:
- Auto-detects biometric availability
- Auto-triggers biometric if available
- Fallback to PIN on user request or biometric failure
- Clear error messages
- Works on devices without biometrics (PIN only)
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
BiometricPrompt provides unified auth experience with automatic fallback.
  </done>
</task>

<task type="auto">
  <name>Task 6: Update auth store for biometric state</name>
  <files>apps/worker-mobile/stores/authStore.ts</files>
  <action>
Extend auth store to track biometric/PIN setup status:

Add to existing authStore:

```typescript
// Add to interface
interface AuthState {
  // ... existing fields
  hasSetupBiometrics: boolean
  hasSetupPin: boolean
  requiresAuthForCheckIn: boolean
}

// Add actions
interface AuthActions {
  // ... existing actions
  setHasSetupBiometrics: (value: boolean) => void
  setHasSetupPin: (value: boolean) => void
  checkAuthSetup: () => Promise<void>
}

// In store implementation, add:
hasSetupBiometrics: false,
hasSetupPin: false,
requiresAuthForCheckIn: true, // Always require for check-in

setHasSetupBiometrics: (value) => set({ hasSetupBiometrics: value }),
setHasSetupPin: (value) => set({ hasSetupPin: value }),

checkAuthSetup: async () => {
  const { checkBiometricSupport } = await import('../lib/biometrics')
  const { hasPin } = await import('../lib/pin-auth')

  const [bioStatus, pinStatus] = await Promise.all([
    checkBiometricSupport(),
    hasPin(),
  ])

  set({
    hasSetupBiometrics: bioStatus.supported && bioStatus.enrolled,
    hasSetupPin: pinStatus,
  })
}
```

This allows the app to:
- Know if user needs to set up PIN during onboarding
- Determine which auth methods are available
- Require auth before check-in/out
  </action>
  <verify>
Run `pnpm typecheck` from apps/worker-mobile.
  </verify>
  <done>
Auth store tracks biometric/PIN setup state.
  </done>
</task>

</tasks>

<verification>
1. On device with biometrics - BiometricPrompt shows fingerprint/face option
2. On device without biometrics - Goes directly to PIN entry
3. Biometric failure allows fallback to PIN
4. Wrong PIN shows error and attempt counter
5. After 5 wrong PINs, 30 second lockout activates
6. PIN setup flow requires confirmation (enter twice)
</verification>

<success_criteria>
- Biometric auth works on supported devices
- PIN fallback available when biometrics fail
- PIN is 4-6 digits, stored securely with SHA-256 hash
- Maximum attempt lockout prevents brute force
- BiometricPrompt handles all edge cases gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/13-scale-features/13-09-SUMMARY.md`
</output>
