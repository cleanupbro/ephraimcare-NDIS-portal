---
phase: 07-invoicing
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - apps/admin/app/api/invoices/generate/route.ts
  - apps/admin/app/(protected)/invoices/generate/page.tsx
  - apps/admin/hooks/use-invoices.ts
autonomous: true

must_haves:
  truths:
    - "Admin can select a participant and date range to generate an invoice"
    - "Generation API fetches completed shifts, calculates lesser-of billing, creates invoice + line items"
    - "If no completed shifts exist in range, API returns error and no invoice is created"
    - "Each line item has correct billable_minutes (lesser of scheduled vs actual)"
    - "Invoice number is generated via next_invoice_number RPC in INV-YYYY-NNN format"
    - "Rates are snapshotted into line items at generation time"
    - "After generation, user is redirected to invoice preview page"
  artifacts:
    - path: "apps/admin/app/api/invoices/generate/route.ts"
      provides: "Invoice generation API"
      exports: ["POST"]
    - path: "apps/admin/app/(protected)/invoices/generate/page.tsx"
      provides: "Generate invoice form page"
      min_lines: 80
    - path: "apps/admin/hooks/use-invoices.ts"
      provides: "Invoice query and mutation hooks"
      exports: ["useInvoices", "useInvoice", "useGenerateInvoice", "useFinalizeInvoice"]
  key_links:
    - from: "apps/admin/app/(protected)/invoices/generate/page.tsx"
      to: "apps/admin/hooks/use-invoices.ts"
      via: "useGenerateInvoice mutation hook"
      pattern: "useGenerateInvoice"
    - from: "apps/admin/app/api/invoices/generate/route.ts"
      to: "apps/admin/lib/invoices/calculations.ts"
      via: "calculateBillableMinutes, getDayType, getRate, calculateLineTotal imports"
      pattern: "calculateBillableMinutes|getDayType"
    - from: "apps/admin/app/api/invoices/generate/route.ts"
      to: "next_invoice_number RPC"
      via: "supabase.rpc call"
      pattern: "rpc.*next_invoice_number"
---

<objective>
Build the invoice generation flow: an API route that fetches completed shifts for a participant/date range, calculates billing using the lesser-of rule with tiered rates, generates a sequential invoice number, and inserts the invoice with line items. Plus the generate form page where admin selects participant and date range.

Purpose: This is the core INVC-01 through INVC-07 functionality -- the heart of the invoicing system.
Output: API route, generate page, and invoice hooks file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-invoicing/07-RESEARCH.md
@.planning/phases/07-invoicing/07-CONTEXT.md
@.planning/phases/07-invoicing/07-01-SUMMARY.md
@.planning/phases/07-invoicing/07-02-SUMMARY.md
@apps/admin/app/api/shifts/[id]/override-checkout/route.ts
@apps/admin/lib/invoices/calculations.ts
@apps/admin/lib/invoices/schemas.ts
@apps/admin/lib/invoices/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invoice generation API route</name>
  <files>apps/admin/app/api/invoices/generate/route.ts</files>
  <action>
Create POST route handler following the override-checkout pattern (auth check, Zod validation, try/catch):

1. Parse and validate body with generateInvoiceSchema
2. Auth check: getUser() + verify admin/coordinator role from profiles table
3. Get user's organization_id from profile

4. Fetch completed shifts in date range:
   - supabase.from('shifts') (as any)
   - .select('id, scheduled_start, scheduled_end, support_type, shift_check_ins(check_in_time, check_out_time, duration_minutes)')
   - .eq('participant_id', participant_id)
   - .eq('status', 'completed')
   - .gte('scheduled_start', period_start + 'T00:00:00')
   - .lte('scheduled_start', period_end + 'T23:59:59')
   - .order('scheduled_start', { ascending: true })

5. If no shifts: return 400 { error: 'No billable shifts found in the specified date range' }

6. Fetch active rates: supabase.from('support_type_rates') (as any) .select('*').eq('is_active', true).eq('organization_id', orgId)

7. If no rates configured: return 400 { error: 'No support type rates configured. Please configure rates in Settings before generating invoices.' }

8. Fetch public holidays in range: supabase.from('public_holidays') (as any) .select('holiday_date').eq('organization_id', orgId).gte('holiday_date', period_start).lte('holiday_date', period_end)

9. Generate invoice number via RPC:
   const { data: invoiceNumber, error: rpcError } = await supabase.rpc('next_invoice_number', { p_organization_id: orgId })
   If error: return 500

10. Build line items array by mapping over shifts:
    - For each shift, get shift_check_ins[0] (or null if missing)
    - scheduledStart/End from shift.scheduled_start/end
    - If check-in exists: actualStart = check_in_time, actualEnd = check_out_time
    - If NO check-in (edge case): use scheduled times as both scheduled and actual
    - billableMinutes = calculateBillableMinutes(scheduledStart, scheduledEnd, actualStart, actualEnd)
    - dayType = getDayType(new Date(shift.scheduled_start), holidays.map(h => h.holiday_date))
    - Find matching rate by support_type. If no rate found for this support type, skip with warning or use 0
    - rate = getRate(matchedRate, dayType)
    - lineTotal = calculateLineTotal(billableMinutes, rate)
    - Build line item object with all fields

11. Calculate totals: calculateInvoiceTotals(lineItems.map(li => li.line_total))

12. Insert invoice:
    supabase.from('invoices') (as any) .insert({
      invoice_number: invoiceNumber,
      participant_id,
      invoice_date: new Date().toISOString().split('T')[0],
      period_start,
      period_end,
      subtotal: totals.subtotal,
      gst: totals.gst,
      total: totals.total,
      status: 'draft',
      organization_id: orgId,
      created_by: user.id,
    }).select().single()

13. Insert line items:
    supabase.from('invoice_line_items') (as any) .insert(lineItems.map(item => ({
      invoice_id: invoice.id,
      shift_id: item.shift_id,
      ndis_item_number: item.ndis_item_number || '',
      description: item.description,
      service_date: item.service_date,
      support_type: item.support_type,
      day_type: item.day_type,
      scheduled_minutes: item.scheduled_minutes,
      actual_minutes: item.actual_minutes,
      billable_minutes: item.billable_minutes,
      quantity: item.quantity,
      unit_price: item.unit_price,
      line_total: item.line_total,
    })))

14. Return 201 with { invoice, line_items: insertedLineItems }

Import from:
- '@/lib/invoices/calculations' (calculateBillableMinutes, getDayType, getRate, calculateLineTotal, calculateInvoiceTotals)
- '@/lib/invoices/schemas' (generateInvoiceSchema)
- 'date-fns' (differenceInMinutes, format)
- 'next/server' (NextResponse)
- '@/lib/supabase/server' (createClient)

Handle errors at each step with appropriate status codes.
  </action>
  <verify>Check file exists. Verify it imports from calculations.ts. Verify it calls supabase.rpc('next_invoice_number'). Verify it checks for empty shifts array before proceeding.</verify>
  <done>POST /api/invoices/generate accepts {participant_id, period_start, period_end}, fetches shifts, calculates billing, generates invoice number, inserts invoice + line items, returns the created invoice.</done>
</task>

<task type="auto">
  <name>Task 2: Create generate page and invoice hooks</name>
  <files>apps/admin/hooks/use-invoices.ts, apps/admin/app/(protected)/invoices/generate/page.tsx</files>
  <action>
**use-invoices.ts** - TanStack Query hooks:

1. useInvoices() hook:
   - queryKey: ['invoices']
   - Fetch invoices with participant join: .from('invoices').select('*, participants(first_name, last_name, ndis_number)').order('created_at', { ascending: false })
   - Cast as any for PostgREST

2. useInvoice(id: string) hook:
   - queryKey: ['invoices', id]
   - Fetch single invoice with line items: .from('invoices').select('*, invoice_line_items(*), participants(first_name, last_name, ndis_number)').eq('id', id).single()
   - enabled: !!id

3. useGenerateInvoice() mutation:
   - mutationFn: POST to /api/invoices/generate with body
   - onSuccess: invalidateQueries(['invoices']), toast success, return data for redirect
   - onError: toast error with message from response

4. useFinalizeInvoice() mutation:
   - mutationFn: POST to /api/invoices/{id}/finalize
   - onSuccess: invalidateQueries(['invoices']), invalidateQueries(['invoices', id]), toast success
   - onError: toast error

**generate/page.tsx** - Client component ('use client'):

Per CONTEXT.md: "Dedicated top-level Invoices page with participant selector and date range picker"

Layout:
- Back button/link to /invoices
- Page title: "Generate Invoice"
- Form with:
  - Participant selector: fetch all participants via supabase, show as a Select/Combobox with search (name + NDIS number displayed)
  - Date range: period_start and period_end date inputs (native or shadcn DatePicker if available)
  - Default period_start: first day of previous month
  - Default period_end: last day of previous month
- "Generate Invoice" submit button
- Loading state while generating (disable button, show spinner)
- On success: redirect to /invoices/[id] (the generated invoice's detail page) using router.push
- On error: show error message (e.g., "No billable shifts found")
- Validation: all 3 fields required, end >= start

Use react-hook-form + zodResolver with generateInvoiceSchema for form validation.

Fetch participants list with: supabase.from('participants').select('id, first_name, last_name, ndis_number').eq('is_active', true).order('first_name')
This can be a simple useQuery or fetched in a useEffect.
  </action>
  <verify>Check both files exist. Verify useGenerateInvoice calls /api/invoices/generate. Verify generate page has participant selector and date range inputs. Verify redirect on success.</verify>
  <done>Generate page allows admin to select participant + date range. On submit, calls API which creates invoice. Success redirects to invoice detail. Error shows message. Hooks provide useInvoices/useInvoice for list and detail pages.</done>
</task>

</tasks>

<verification>
- POST /api/invoices/generate returns 201 with invoice data for valid input
- POST /api/invoices/generate returns 400 when no completed shifts in range
- Generate page validates form before submission
- On successful generation, router navigates to /invoices/[id]
- Invoice number is in INV-YYYY-NNN format (from RPC)
- Line items have correct billable_minutes (lesser of scheduled vs actual)
</verification>

<success_criteria>
- INVC-01: Admin can generate invoice for participant within date range
- INVC-02: Billing uses lesser of scheduled vs actual duration
- INVC-03: Exact minutes (no rounding in calculation)
- INVC-04: Rate multiplied by hours
- INVC-07: Sequential INV-YYYY-NNN format
- Rates snapshotted into line items at generation time
</success_criteria>

<output>
After completion, create `.planning/phases/07-invoicing/07-04-SUMMARY.md`
</output>
